// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Compute Engine API (compute/v1)
// Description:
//   Creates and runs virtual machines on Google Cloud Platform.
// Documentation:
//   https://developers.google.com/compute/docs/reference/latest/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRQuery.h"
#else
  #import "GTLRQuery.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCompute_AccessConfig;
@class GTLRCompute_Address;
@class GTLRCompute_AttachedDisk;
@class GTLRCompute_Autoscaler;
@class GTLRCompute_BackendBucket;
@class GTLRCompute_BackendService;
@class GTLRCompute_CacheInvalidationRule;
@class GTLRCompute_Commitment;
@class GTLRCompute_DeprecationStatus;
@class GTLRCompute_Disk;
@class GTLRCompute_DiskMoveRequest;
@class GTLRCompute_DisksResizeRequest;
@class GTLRCompute_Firewall;
@class GTLRCompute_ForwardingRule;
@class GTLRCompute_GlobalSetLabelsRequest;
@class GTLRCompute_HealthCheck;
@class GTLRCompute_HttpHealthCheck;
@class GTLRCompute_HttpsHealthCheck;
@class GTLRCompute_Image;
@class GTLRCompute_Instance;
@class GTLRCompute_InstanceGroup;
@class GTLRCompute_InstanceGroupManager;
@class GTLRCompute_InstanceGroupManagersAbandonInstancesRequest;
@class GTLRCompute_InstanceGroupManagersDeleteInstancesRequest;
@class GTLRCompute_InstanceGroupManagersRecreateInstancesRequest;
@class GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest;
@class GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest;
@class GTLRCompute_InstanceGroupsAddInstancesRequest;
@class GTLRCompute_InstanceGroupsListInstancesRequest;
@class GTLRCompute_InstanceGroupsRemoveInstancesRequest;
@class GTLRCompute_InstanceGroupsSetNamedPortsRequest;
@class GTLRCompute_InstanceMoveRequest;
@class GTLRCompute_InstanceReference;
@class GTLRCompute_InstancesSetLabelsRequest;
@class GTLRCompute_InstancesSetMachineResourcesRequest;
@class GTLRCompute_InstancesSetMachineTypeRequest;
@class GTLRCompute_InstancesSetMinCpuPlatformRequest;
@class GTLRCompute_InstancesSetServiceAccountRequest;
@class GTLRCompute_InstancesStartWithEncryptionKeyRequest;
@class GTLRCompute_InstanceTemplate;
@class GTLRCompute_Metadata;
@class GTLRCompute_Network;
@class GTLRCompute_NetworksAddPeeringRequest;
@class GTLRCompute_NetworksRemovePeeringRequest;
@class GTLRCompute_ProjectsDisableXpnResourceRequest;
@class GTLRCompute_ProjectsEnableXpnResourceRequest;
@class GTLRCompute_ProjectsListXpnHostsRequest;
@class GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest;
@class GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest;
@class GTLRCompute_RegionInstanceGroupManagersRecreateRequest;
@class GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest;
@class GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest;
@class GTLRCompute_RegionInstanceGroupsListInstancesRequest;
@class GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest;
@class GTLRCompute_ResourceGroupReference;
@class GTLRCompute_Route;
@class GTLRCompute_Router;
@class GTLRCompute_Scheduling;
@class GTLRCompute_Snapshot;
@class GTLRCompute_SslCertificate;
@class GTLRCompute_Subnetwork;
@class GTLRCompute_SubnetworksExpandIpCidrRangeRequest;
@class GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest;
@class GTLRCompute_Tags;
@class GTLRCompute_TargetHttpProxy;
@class GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest;
@class GTLRCompute_TargetHttpsProxy;
@class GTLRCompute_TargetInstance;
@class GTLRCompute_TargetPool;
@class GTLRCompute_TargetPoolsAddHealthCheckRequest;
@class GTLRCompute_TargetPoolsAddInstanceRequest;
@class GTLRCompute_TargetPoolsRemoveHealthCheckRequest;
@class GTLRCompute_TargetPoolsRemoveInstanceRequest;
@class GTLRCompute_TargetReference;
@class GTLRCompute_TargetSslProxiesSetBackendServiceRequest;
@class GTLRCompute_TargetSslProxiesSetProxyHeaderRequest;
@class GTLRCompute_TargetSslProxiesSetSslCertificatesRequest;
@class GTLRCompute_TargetSslProxy;
@class GTLRCompute_TargetTcpProxiesSetBackendServiceRequest;
@class GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest;
@class GTLRCompute_TargetTcpProxy;
@class GTLRCompute_TargetVpnGateway;
@class GTLRCompute_UrlMap;
@class GTLRCompute_UrlMapReference;
@class GTLRCompute_UrlMapsValidateRequest;
@class GTLRCompute_UsageExportLocation;
@class GTLRCompute_VpnTunnel;
@class GTLRCompute_ZoneSetLabelsRequest;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

/**
 *  Parent class for other Compute query classes.
 */
@interface GTLRComputeQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(nonatomic, copy, nullable) NSString *fields;

@end

/**
 *  Retrieves an aggregated list of accelerator types.
 *
 *  Method: compute.acceleratorTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAcceleratorTypesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AcceleratorTypeAggregatedList.
 *
 *  Retrieves an aggregated list of accelerator types.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_AcceleratorTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified accelerator type. Get a list of available accelerator
 *  types by making a list() request.
 *
 *  Method: compute.acceleratorTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAcceleratorTypesGetWithproject:zoneProperty:acceleratorType:]

/** Name of the accelerator type to return. */
@property(nonatomic, copy, nullable) NSString *acceleratorType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AcceleratorType.
 *
 *  Returns the specified accelerator type. Get a list of available accelerator
 *  types by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param acceleratorType Name of the accelerator type to return.
 *
 *  @returns GTLRComputeQuery_AcceleratorTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                 acceleratorType:(NSString *)acceleratorType;

@end

/**
 *  Retrieves a list of accelerator types available to the specified project.
 *
 *  Method: compute.acceleratorTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAcceleratorTypesListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AcceleratorTypeList.
 *
 *  Retrieves a list of accelerator types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AcceleratorTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves an aggregated list of addresses.
 *
 *  Method: compute.addresses.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AddressAggregatedList.
 *
 *  Retrieves an aggregated list of addresses.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_AddressesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.addresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesDeleteWithproject:region:address:]

/** Name of the address resource to delete. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @returns GTLRComputeQuery_AddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource.
 *
 *  Method: compute.addresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesGetWithproject:region:address:]

/** Name of the address resource to return. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to return.
 *
 *  @returns GTLRComputeQuery_AddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.addresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_AddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  Method: compute.addresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_AddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves an aggregated list of autoscalers.
 *
 *  Method: compute.autoscalers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AutoscalerAggregatedList.
 *
 *  Retrieves an aggregated list of autoscalers.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified autoscaler.
 *
 *  Method: compute.autoscalers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersDeleteWithproject:zoneProperty:autoscaler:]

/** Name of the autoscaler to delete. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to delete.
 *
 *  @returns GTLRComputeQuery_AutoscalersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Returns the specified autoscaler resource. Get a list of available
 *  autoscalers by making a list() request.
 *
 *  Method: compute.autoscalers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersGetWithproject:zoneProperty:autoscaler:]

/** Name of the autoscaler to return. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Autoscaler.
 *
 *  Returns the specified autoscaler resource. Get a list of available
 *  autoscalers by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to return.
 *
 *  @returns GTLRComputeQuery_AutoscalersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  Method: compute.autoscalers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AutoscalerList.
 *
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.autoscalers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersPatchWithObject:project:zoneProperty:]

/** Name of the autoscaler to patch. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersUpdateWithObject:project:zoneProperty:]

/** Name of the autoscaler to update. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified BackendBucket resource.
 *
 *  Method: compute.backendBuckets.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsDeleteWithproject:backendBucket:]

/** Name of the BackendBucket resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified BackendBucket resource.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to delete.
 *
 *  @returns GTLRComputeQuery_BackendBucketsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket;

@end

/**
 *  Returns the specified BackendBucket resource. Get a list of available
 *  backend buckets by making a list() request.
 *
 *  Method: compute.backendBuckets.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsGetWithproject:backendBucket:]

/** Name of the BackendBucket resource to return. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendBucket.
 *
 *  Returns the specified BackendBucket resource. Get a list of available
 *  backend buckets by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to return.
 *
 *  @returns GTLRComputeQuery_BackendBucketsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket;

@end

/**
 *  Creates a BackendBucket resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.backendBuckets.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a BackendBucket resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_BackendBucketsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of BackendBucket resources available to the specified
 *  project.
 *
 *  Method: compute.backendBuckets.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendBucketList.
 *
 *  Retrieves the list of BackendBucket resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_BackendBucketsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified BackendBucket resource with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.backendBuckets.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsPatchWithObject:project:backendBucket:]

/** Name of the BackendBucket resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendBucket resource with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to patch.
 *
 *  @returns GTLRComputeQuery_BackendBucketsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Updates the specified BackendBucket resource with the data included in the
 *  request.
 *
 *  Method: compute.backendBuckets.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsUpdateWithObject:project:backendBucket:]

/** Name of the BackendBucket resource to update. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendBucket resource with the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to update.
 *
 *  @returns GTLRComputeQuery_BackendBucketsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Retrieves the list of all BackendService resources, regional and global,
 *  available to the specified project.
 *
 *  Method: compute.backendServices.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceAggregatedList.
 *
 *  Retrieves the list of all BackendService resources, regional and global,
 *  available to the specified project.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @returns GTLRComputeQuery_BackendServicesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified BackendService resource.
 *
 *  Method: compute.backendServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesDeleteWithproject:backendService:]

/** Name of the BackendService resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to delete.
 *
 *  @returns GTLRComputeQuery_BackendServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Returns the specified BackendService resource. Get a list of available
 *  backend services by making a list() request.
 *
 *  Method: compute.backendServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesGetWithproject:backendService:]

/** Name of the BackendService resource to return. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendService.
 *
 *  Returns the specified BackendService resource. Get a list of available
 *  backend services by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to return.
 *
 *  @returns GTLRComputeQuery_BackendServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Gets the most recent health check results for this BackendService.
 *
 *  Method: compute.backendServices.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesGetHealthWithObject:project:backendService:]

/**
 *  Name of the BackendService resource to which the queried instance belongs.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceGroupHealth.
 *
 *  Gets the most recent health check results for this BackendService.
 *
 *  @param object The @c GTLRCompute_ResourceGroupReference to include in the
 *    query.
 *  @param project NSString
 *  @param backendService Name of the BackendService resource to which the
 *    queried instance belongs.
 *
 *  @returns GTLRComputeQuery_BackendServicesGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourceGroupReference *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when creating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  Method: compute.backendServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when creating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_BackendServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  Method: compute.backendServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceList.
 *
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_BackendServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.backendServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesPatchWithObject:project:backendService:]

/** Name of the BackendService resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to patch.
 *
 *  @returns GTLRComputeQuery_BackendServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Updates the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information.
 *
 *  Method: compute.backendServices.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesUpdateWithObject:project:backendService:]

/** Name of the BackendService resource to update. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @returns GTLRComputeQuery_BackendServicesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves an aggregated list of persistent disks.
 *
 *  Method: compute.disks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_DiskAggregatedList.
 *
 *  Retrieves an aggregated list of persistent disks.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_DisksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Creates a snapshot of a specified persistent disk.
 *
 *  Method: compute.disks.createSnapshot
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksCreateSnapshot : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksCreateSnapshotWithObject:project:zoneProperty:disk:]

/** Name of the persistent disk to snapshot. */
@property(nonatomic, copy, nullable) NSString *disk;

@property(nonatomic, assign) BOOL guestFlush;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a snapshot of a specified persistent disk.
 *
 *  @param object The @c GTLRCompute_Snapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to snapshot.
 *
 *  @returns GTLRComputeQuery_DisksCreateSnapshot
 */
+ (instancetype)queryWithObject:(GTLRCompute_Snapshot *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  Method: compute.disks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksDeleteWithproject:zoneProperty:disk:]

/** Name of the persistent disk to delete. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to delete.
 *
 *  @returns GTLRComputeQuery_DisksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Returns a specified persistent disk. Get a list of available persistent
 *  disks by making a list() request.
 *
 *  Method: compute.disks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksGetWithproject:zoneProperty:disk:]

/** Name of the persistent disk to return. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Disk.
 *
 *  Returns a specified persistent disk. Get a list of available persistent
 *  disks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to return.
 *
 *  @returns GTLRComputeQuery_DisksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk with a sourceImage, a sourceSnapshot, or
 *  create an empty 500 GB data disk by omitting all properties. You can also
 *  create a disk that is larger than the default size by specifying the sizeGb
 *  property.
 *
 *  Method: compute.disks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Optional. Source image to restore onto a disk. */
@property(nonatomic, copy, nullable) NSString *sourceImage;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk with a sourceImage, a sourceSnapshot, or
 *  create an empty 500 GB data disk by omitting all properties. You can also
 *  create a disk that is larger than the default size by specifying the sizeGb
 *  property.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_DisksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  Method: compute.disks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskList.
 *
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_DisksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Resizes the specified persistent disk.
 *
 *  Method: compute.disks.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksResizeWithObject:project:zoneProperty:disk:]

/** The name of the persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the specified persistent disk.
 *
 *  @param object The @c GTLRCompute_DisksResizeRequest to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @returns GTLRComputeQuery_DisksResize
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksResizeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Sets the labels on a disk. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.disks.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksSetLabelsWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a disk. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_ZoneSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name of the resource for this request.
 *
 *  @returns GTLRComputeQuery_DisksSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetLabelsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of disk types.
 *
 *  Method: compute.diskTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_DiskTypeAggregatedList.
 *
 *  Retrieves an aggregated list of disk types.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_DiskTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified disk type. Get a list of available disk types by
 *  making a list() request.
 *
 *  Method: compute.diskTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesGetWithproject:zoneProperty:diskType:]

/** Name of the disk type to return. */
@property(nonatomic, copy, nullable) NSString *diskType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskType.
 *
 *  Returns the specified disk type. Get a list of available disk types by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param diskType Name of the disk type to return.
 *
 *  @returns GTLRComputeQuery_DiskTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        diskType:(NSString *)diskType;

@end

/**
 *  Retrieves a list of disk types available to the specified project.
 *
 *  Method: compute.diskTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskTypeList.
 *
 *  Retrieves a list of disk types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_DiskTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified firewall.
 *
 *  Method: compute.firewalls.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsDeleteWithproject:firewall:]

/** Name of the firewall rule to delete. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to delete.
 *
 *  @returns GTLRComputeQuery_FirewallsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Returns the specified firewall.
 *
 *  Method: compute.firewalls.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsGetWithproject:firewall:]

/** Name of the firewall rule to return. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Firewall.
 *
 *  Returns the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to return.
 *
 *  @returns GTLRComputeQuery_FirewallsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.firewalls.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_FirewallsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  Method: compute.firewalls.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_FirewallList.
 *
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_FirewallsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.firewalls.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsPatchWithObject:project:firewall:]

/** Name of the firewall rule to patch. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to patch.
 *
 *  @returns GTLRComputeQuery_FirewallsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *  Using PUT method, can only update following fields of firewall rule:
 *  allowed, description, sourceRanges, sourceTags, targetTags.
 *
 *  Method: compute.firewalls.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsUpdateWithObject:project:firewall:]

/** Name of the firewall rule to update. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *  Using PUT method, can only update following fields of firewall rule:
 *  allowed, description, sourceRanges, sourceTags, targetTags.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to update.
 *
 *  @returns GTLRComputeQuery_FirewallsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Retrieves an aggregated list of forwarding rules.
 *
 *  Method: compute.forwardingRules.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleAggregatedList.
 *
 *  Retrieves an aggregated list of forwarding rules.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesDeleteWithproject:region:forwardingRule:]

/** Name of the ForwardingRule resource to delete. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesGetWithproject:region:forwardingRule:]

/** Name of the ForwardingRule resource to return. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.forwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  Method: compute.forwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  Method: compute.forwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesSetTarget : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesSetTargetWithObject:project:region:forwardingRule:]

/** Name of the ForwardingRule resource in which target is to be set. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.globalAddresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesDeleteWithproject:address:]

/** Name of the address resource to delete. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource. Get a list of available addresses by
 *  making a list() request.
 *
 *  Method: compute.globalAddresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesGetWithproject:address:]

/** Name of the address resource to return. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource. Get a list of available addresses by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to return.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.globalAddresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of global addresses.
 *
 *  Method: compute.globalAddresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of global addresses.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified GlobalForwardingRule resource.
 *
 *  Method: compute.globalForwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesDeleteWithproject:forwardingRule:]

/** Name of the ForwardingRule resource to delete. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified GlobalForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified GlobalForwardingRule resource. Get a list of available
 *  forwarding rules by making a list() request.
 *
 *  Method: compute.globalForwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesGetWithproject:forwardingRule:]

/** Name of the ForwardingRule resource to return. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified GlobalForwardingRule resource. Get a list of available
 *  forwarding rules by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a GlobalForwardingRule resource in the specified project using the
 *  data included in the request.
 *
 *  Method: compute.globalForwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a GlobalForwardingRule resource in the specified project using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of GlobalForwardingRule resources available to the
 *  specified project.
 *
 *  Method: compute.globalForwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of GlobalForwardingRule resources available to the
 *  specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes target URL for the GlobalForwardingRule resource. The new target
 *  should be of the same type as the old target.
 *
 *  Method: compute.globalForwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesSetTarget : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesSetTargetWithObject:project:forwardingRule:]

/** Name of the ForwardingRule resource in which target is to be set. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for the GlobalForwardingRule resource. The new target
 *  should be of the same type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Retrieves an aggregated list of all operations.
 *
 *  Method: compute.globalOperations.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_OperationAggregatedList.
 *
 *  Retrieves an aggregated list of all operations.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Operations resource.
 *
 *  Method: compute.globalOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsDeleteWithproject:operation:]

/** Name of the Operations resource to delete. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified Operations resource. Get a list of operations by
 *  making a list() request.
 *
 *  Method: compute.globalOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsGetWithproject:operation:]

/** Name of the Operations resource to return. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified Operations resource. Get a list of operations by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  Method: compute.globalOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified HealthCheck resource.
 *
 *  Method: compute.healthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksDeleteWithproject:healthCheck:]

/** Name of the HealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to delete.
 *
 *  @returns GTLRComputeQuery_HealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Returns the specified HealthCheck resource. Get a list of available health
 *  checks by making a list() request.
 *
 *  Method: compute.healthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksGetWithproject:healthCheck:]

/** Name of the HealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HealthCheck.
 *
 *  Returns the specified HealthCheck resource. Get a list of available health
 *  checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to return.
 *
 *  @returns GTLRComputeQuery_HealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.healthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.healthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HealthCheckList.
 *
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.healthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksPatchWithObject:project:healthCheck:]

/** Name of the HealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to patch.
 *
 *  @returns GTLRComputeQuery_HealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.healthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksUpdateWithObject:project:healthCheck:]

/** Name of the HealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to update.
 *
 *  @returns GTLRComputeQuery_HealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  Method: compute.httpHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksDeleteWithproject:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to delete.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Returns the specified HttpHealthCheck resource. Get a list of available HTTP
 *  health checks by making a list() request.
 *
 *  Method: compute.httpHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksGetWithproject:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheck.
 *
 *  Returns the specified HttpHealthCheck resource. Get a list of available HTTP
 *  health checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to return.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheckList.
 *
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.httpHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksPatchWithObject:project:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to patch.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksUpdateWithObject:project:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to update.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  Method: compute.httpsHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksDeleteWithproject:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to delete.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Returns the specified HttpsHealthCheck resource. Get a list of available
 *  HTTPS health checks by making a list() request.
 *
 *  Method: compute.httpsHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksGetWithproject:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheck.
 *
 *  Returns the specified HttpsHealthCheck resource. Get a list of available
 *  HTTPS health checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to return.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpsHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheckList.
 *
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.httpsHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksPatchWithObject:project:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to patch.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksUpdateWithObject:project:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to update.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Deletes the specified image.
 *
 *  Method: compute.images.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesDeleteWithproject:image:]

/** Name of the image resource to delete. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified image.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to delete.
 *
 *  @returns GTLRComputeQuery_ImagesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Sets the deprecation status of an image.
 *  If an empty request body is given, clears the deprecation status instead.
 *
 *  Method: compute.images.deprecate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDeprecate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesDeprecateWithObject:project:image:]

/** Image name. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the deprecation status of an image.
 *  If an empty request body is given, clears the deprecation status instead.
 *
 *  @param object The @c GTLRCompute_DeprecationStatus to include in the query.
 *  @param project Project ID for this request.
 *  @param image Image name.
 *
 *  @returns GTLRComputeQuery_ImagesDeprecate
 */
+ (instancetype)queryWithObject:(GTLRCompute_DeprecationStatus *)object
                        project:(NSString *)project
                          image:(NSString *)image;

@end

/**
 *  Returns the specified image. Get a list of available images by making a
 *  list() request.
 *
 *  Method: compute.images.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesGetWithproject:image:]

/** Name of the image resource to return. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the specified image. Get a list of available images by making a
 *  list() request.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to return.
 *
 *  @returns GTLRComputeQuery_ImagesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Returns the latest image that is part of an image family and is not
 *  deprecated.
 *
 *  Method: compute.images.getFromFamily
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGetFromFamily : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesGetFromFamilyWithproject:family:]

/** Name of the image family to search for. */
@property(nonatomic, copy, nullable) NSString *family;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the latest image that is part of an image family and is not
 *  deprecated.
 *
 *  @param project Project ID for this request.
 *  @param family Name of the image family to search for.
 *
 *  @returns GTLRComputeQuery_ImagesGetFromFamily
 */
+ (instancetype)queryWithProject:(NSString *)project
                          family:(NSString *)family;

@end

/**
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.images.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ImagesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesInsertWithObject:project:]

/** Force image creation if true. */
@property(nonatomic, assign) BOOL forceCreate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Image to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ImagesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Image *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of private images available to the specified project.
 *  Private images are images you create that belong to your project. This
 *  method does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 8. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *
 *  Method: compute.images.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ImageList.
 *
 *  Retrieves the list of private images available to the specified project.
 *  Private images are images you create that belong to your project. This
 *  method does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 8. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ImagesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the labels on an image. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.images.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesSetLabelsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on an image. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name of the resource for this request.
 *
 *  @returns GTLRComputeQuery_ImagesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Schedules a group action to remove the specified instances from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.abandonInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersAbandonInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersAbandonInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to remove the specified instances from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersAbandonInstancesRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersAbandonInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersAbandonInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Retrieves the list of managed instance groups and groups them by zone.
 *
 *  Method: compute.instanceGroupManagers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerAggregatedList.
 *
 *  Retrieves the list of managed instance groups and groups them by zone.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroupManagers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersDeleteWithproject:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group to
 *    delete.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Schedules a group action to delete the specified instances in the managed
 *  instance group. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. This operation is
 *  marked as DONE when the action is scheduled even if the instances are still
 *  being deleted. You must separately verify the status of the deleting action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.deleteInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDeleteInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersDeleteInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to delete the specified instances in the managed
 *  instance group. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. This operation is
 *  marked as DONE when the action is scheduled even if the instances are still
 *  being deleted. You must separately verify the status of the deleting action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersDeleteInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersDeleteInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersDeleteInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns all of the details about the specified managed instance group. Get a
 *  list of available managed instance groups by making a list() request.
 *
 *  Method: compute.instanceGroupManagers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersGetWithproject:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManager.
 *
 *  Returns all of the details about the specified managed instance group. Get a
 *  list of available managed instance groups by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, it schedules an action to create
 *  instances in the group using the specified instance template. This operation
 *  is marked as DONE when the group is created even if the instances in the
 *  group have not yet been created. You must separately verify the status of
 *  the individual instances with the listmanagedinstances method.
 *  A managed instance group can have up to 1000 VM instances per group. Please
 *  contact Cloud Support if you need an increase in this limit.
 *
 *  Method: compute.instanceGroupManagers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the managed instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, it schedules an action to create
 *  instances in the group using the specified instance template. This operation
 *  is marked as DONE when the group is created even if the instances in the
 *  group have not yet been created. You must separately verify the status of
 *  the individual instances with the listmanagedinstances method.
 *  A managed instance group can have up to 1000 VM instances per group. Please
 *  contact Cloud Support if you need an increase in this limit.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  Method: compute.instanceGroupManagers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerList.
 *
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action.
 *
 *  Method: compute.instanceGroupManagers.listManagedInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersListManagedInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersListManagedInstancesWithproject:zoneProperty:instanceGroupManager:]

@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  maxResults
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

@property(nonatomic, copy, nullable) NSString *orderBy;

@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagersListManagedInstancesResponse.
 *
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersListManagedInstances
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Schedules a group action to recreate the specified instances in the managed
 *  instance group. The instances are deleted and recreated using the current
 *  instance template for the managed instance group. This operation is marked
 *  as DONE when the action is scheduled even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.recreateInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersRecreateInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersRecreateInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to recreate the specified instances in the managed
 *  instance group. The instances are deleted and recreated using the current
 *  instance template for the managed instance group. This operation is marked
 *  as DONE when the action is scheduled even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersRecreateInstancesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersRecreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersRecreateInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  Method: compute.instanceGroupManagers.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersResizeWithproject:zoneProperty:instanceGroupManager:size:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The number of running instances that the managed instance group should
 *  maintain at any given time. The group automatically adds or removes
 *  instances to maintain the number of instances specified by this parameter.
 */
@property(nonatomic, assign) NSInteger size;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *  @param size The number of running instances that the managed instance group
 *    should maintain at any given time. The group automatically adds or removes
 *    instances to maintain the number of instances specified by this parameter.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersResize
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager
                            size:(NSInteger)size;

@end

/**
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you recreate them.
 *
 *  Method: compute.instanceGroupManagers.setInstanceTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersSetInstanceTemplateWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you recreate them.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  Method: compute.instanceGroupManagers.setTargetPools
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetTargetPools : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersSetTargetPoolsWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersSetTargetPools
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  Method: compute.instanceGroups.addInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsAddInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsAddInstancesWithObject:project:zoneProperty:instanceGroup:]

/** The name of the instance group where you are adding instances. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsAddInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where you are adding
 *    instances.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsAddInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsAddInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Retrieves the list of instance groups and sorts them by zone.
 *
 *  Method: compute.instanceGroups.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupAggregatedList.
 *
 *  Retrieves the list of instance groups and sorts them by zone.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsDeleteWithproject:zoneProperty:instanceGroup:]

/** The name of the instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group to delete.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Returns the specified instance group. Get a list of available instance
 *  groups by making a list() request.
 *
 *  Method: compute.instanceGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsGetWithproject:zoneProperty:instanceGroup:]

/** The name of the instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroup.
 *
 *  Returns the specified instance group. Get a list of available instance
 *  groups by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  Method: compute.instanceGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  @param object The @c GTLRCompute_InstanceGroup to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of instance groups that are located in the specified
 *  project and zone.
 *
 *  Method: compute.instanceGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupList.
 *
 *  Retrieves the list of instance groups that are located in the specified
 *  project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists the instances in the specified instance group.
 *
 *  Method: compute.instanceGroups.listInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsListInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsListInstancesWithObject:project:zoneProperty:instanceGroup:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The name of the instance group from which you want to generate a list of
 *  included instances.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupsListInstances.
 *
 *  Lists the instances in the specified instance group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsListInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group from which you want to
 *    generate a list of included instances.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsListInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsListInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration before the VM instance is removed or deleted.
 *
 *  Method: compute.instanceGroups.removeInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsRemoveInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsRemoveInstancesWithObject:project:zoneProperty:instanceGroup:]

/**
 *  The name of the instance group where the specified instances will be
 *  removed.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration before the VM instance is removed or deleted.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsRemoveInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the specified
 *    instances will be removed.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsRemoveInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsRemoveInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Sets the named ports for the specified instance group.
 *
 *  Method: compute.instanceGroups.setNamedPorts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsSetNamedPorts : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsSetNamedPortsWithObject:project:zoneProperty:instanceGroup:]

/** The name of the instance group where the named ports are updated. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the named ports for the specified instance group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsSetNamedPortsRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the named ports
 *    are updated.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsSetNamedPorts
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsSetNamedPortsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Adds an access config to an instance's network interface.
 *
 *  Method: compute.instances.addAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAddAccessConfig : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAddAccessConfigWithObject:project:zoneProperty:instance:networkInterface:]

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface to add to this instance. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an access config to an instance's network interface.
 *
 *  @param object The @c GTLRCompute_AccessConfig to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface to add to this
 *    instance.
 *
 *  @returns GTLRComputeQuery_InstancesAddAccessConfig
 */
+ (instancetype)queryWithObject:(GTLRCompute_AccessConfig *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Retrieves aggregated list of instances.
 *
 *  Method: compute.instances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceAggregatedList.
 *
 *  Retrieves aggregated list of instances.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Attaches an existing Disk resource to an instance. You must first create the
 *  disk before you can attach it. It is not possible to create and attach a
 *  disk at the same time. For more information, read Adding a persistent disk
 *  to your instance.
 *
 *  Method: compute.instances.attachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAttachDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAttachDiskWithObject:project:zoneProperty:instance:]

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Attaches an existing Disk resource to an instance. You must first create the
 *  disk before you can attach it. It is not possible to create and attach a
 *  disk at the same time. For more information, read Adding a persistent disk
 *  to your instance.
 *
 *  @param object The @c GTLRCompute_AttachedDisk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *
 *  @returns GTLRComputeQuery_InstancesAttachDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_AttachedDisk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Deletes the specified Instance resource. For more information, see Stopping
 *  or Deleting an Instance.
 *
 *  Method: compute.instances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDeleteWithproject:zoneProperty:instance:]

/** Name of the instance resource to delete. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Instance resource. For more information, see Stopping
 *  or Deleting an Instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to delete.
 *
 *  @returns GTLRComputeQuery_InstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Deletes an access config from an instance's network interface.
 *
 *  Method: compute.instances.deleteAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDeleteAccessConfig : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDeleteAccessConfigWithproject:zoneProperty:instance:accessConfig:networkInterface:]

/** The name of the access config to delete. */
@property(nonatomic, copy, nullable) NSString *accessConfig;

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes an access config from an instance's network interface.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param accessConfig The name of the access config to delete.
 *  @param networkInterface The name of the network interface.
 *
 *  @returns GTLRComputeQuery_InstancesDeleteAccessConfig
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                    accessConfig:(NSString *)accessConfig
                networkInterface:(NSString *)networkInterface;

@end

/**
 *  Detaches a disk from an instance.
 *
 *  Method: compute.instances.detachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDetachDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDetachDiskWithproject:zoneProperty:instance:deviceName:]

/** Disk device name to detach. */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** Instance name. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Detaches a disk from an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name.
 *  @param deviceName Disk device name to detach.
 *
 *  @returns GTLRComputeQuery_InstancesDetachDisk
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Returns the specified Instance resource. Get a list of available instances
 *  by making a list() request.
 *
 *  Method: compute.instances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesGetWithproject:zoneProperty:instance:]

/** Name of the instance resource to return. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Instance.
 *
 *  Returns the specified Instance resource. Get a list of available instances
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to return.
 *
 *  @returns GTLRComputeQuery_InstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Returns the specified instance's serial port output.
 *
 *  Method: compute.instances.getSerialPortOutput
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetSerialPortOutput : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesGetSerialPortOutputWithproject:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  Specifies which COM or serial port to retrieve data from.
 *
 *  @note If not set, the documented server-side default will be 1 (from the
 *        range 1..4).
 */
@property(nonatomic, assign) NSInteger port;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Returns output starting from a specific byte position. Use this to page
 *  through output when the output is too large to return in a single request.
 *  For the initial request, leave this field unspecified. For subsequent calls,
 *  this field should be set to the next value returned in the previous call.
 */
@property(nonatomic, assign) long long start;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_SerialPortOutput.
 *
 *  Returns the specified instance's serial port output.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesGetSerialPortOutput
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.instances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Instance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_InstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Instance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  Method: compute.instances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceList.
 *
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_InstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Performs a reset on the instance. For more information, see Resetting an
 *  instance.
 *
 *  Method: compute.instances.reset
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesReset : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesResetWithproject:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Performs a reset on the instance. For more information, see Resetting an
 *  instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesReset
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  Method: compute.instances.setDiskAutoDelete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetDiskAutoDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetDiskAutoDeleteWithproject:zoneProperty:instance:autoDelete:deviceName:]

/** Whether to auto-delete the disk when the instance is deleted. */
@property(nonatomic, assign) BOOL autoDelete;

/** The device name of the disk to modify. */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** The instance name. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name.
 *  @param autoDelete Whether to auto-delete the disk when the instance is
 *    deleted.
 *  @param deviceName The device name of the disk to modify.
 *
 *  @returns GTLRComputeQuery_InstancesSetDiskAutoDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      autoDelete:(BOOL)autoDelete
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Sets labels on an instance. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.instances.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetLabelsWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets labels on an instance. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_InstancesSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetLabelsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the number and/or type of accelerator for a stopped instance to the
 *  values specified in the request.
 *
 *  Method: compute.instances.setMachineResources
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMachineResources : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMachineResourcesWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the number and/or type of accelerator for a stopped instance to the
 *  values specified in the request.
 *
 *  @param object The @c GTLRCompute_InstancesSetMachineResourcesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetMachineResources
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMachineResourcesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  Method: compute.instances.setMachineType
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMachineType : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMachineTypeWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  @param object The @c GTLRCompute_InstancesSetMachineTypeRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetMachineType
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMachineTypeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  Method: compute.instances.setMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMetadata : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMetadataWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the minimum CPU platform that this instance should use. This method
 *  can only be called on a stopped instance. For more information, read
 *  Specifying a Minimum CPU Platform.
 *
 *  Method: compute.instances.setMinCpuPlatform
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMinCpuPlatform : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMinCpuPlatformWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the minimum CPU platform that this instance should use. This method
 *  can only be called on a stopped instance. For more information, read
 *  Specifying a Minimum CPU Platform.
 *
 *  @param object The @c GTLRCompute_InstancesSetMinCpuPlatformRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetMinCpuPlatform
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMinCpuPlatformRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets an instance's scheduling options.
 *
 *  Method: compute.instances.setScheduling
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetScheduling : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetSchedulingWithObject:project:zoneProperty:instance:]

/** Instance name. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets an instance's scheduling options.
 *
 *  @param object The @c GTLRCompute_Scheduling to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name.
 *
 *  @returns GTLRComputeQuery_InstancesSetScheduling
 */
+ (instancetype)queryWithObject:(GTLRCompute_Scheduling *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets the service account on the instance. For more information, read
 *  Changing the service account and access scopes for an instance.
 *
 *  Method: compute.instances.setServiceAccount
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetServiceAccount : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetServiceAccountWithObject:project:zoneProperty:instance:]

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the service account on the instance. For more information, read
 *  Changing the service account and access scopes for an instance.
 *
 *  @param object The @c GTLRCompute_InstancesSetServiceAccountRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @returns GTLRComputeQuery_InstancesSetServiceAccount
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetServiceAccountRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets tags for the specified instance to the data included in the request.
 *
 *  Method: compute.instances.setTags
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetTags : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetTagsWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets tags for the specified instance to the data included in the request.
 *
 *  @param object The @c GTLRCompute_Tags to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetTags
 */
+ (instancetype)queryWithObject:(GTLRCompute_Tags *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Starts an instance that was stopped using the using the instances().stop
 *  method. For more information, see Restart an instance.
 *
 *  Method: compute.instances.start
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStart : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStartWithproject:zoneProperty:instance:]

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts an instance that was stopped using the using the instances().stop
 *  method. For more information, see Restart an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @returns GTLRComputeQuery_InstancesStart
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Starts an instance that was stopped using the using the instances().stop
 *  method. For more information, see Restart an instance.
 *
 *  Method: compute.instances.startWithEncryptionKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStartWithEncryptionKey : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStartWithEncryptionKeyWithObject:project:zoneProperty:instance:]

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts an instance that was stopped using the using the instances().stop
 *  method. For more information, see Restart an instance.
 *
 *  @param object The @c GTLRCompute_InstancesStartWithEncryptionKeyRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @returns GTLRComputeQuery_InstancesStartWithEncryptionKey
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesStartWithEncryptionKeyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur
 *  per-minute, virtual machine usage charges while they are stopped, but any
 *  resources that the virtual machine is using, such as persistent disks and
 *  static IP addresses, will continue to be charged until they are deleted. For
 *  more information, see Stopping an instance.
 *
 *  Method: compute.instances.stop
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStop : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStopWithproject:zoneProperty:instance:]

/** Name of the instance resource to stop. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur
 *  per-minute, virtual machine usage charges while they are stopped, but any
 *  resources that the virtual machine is using, such as persistent disks and
 *  static IP addresses, will continue to be charged until they are deleted. For
 *  more information, see Stopping an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to stop.
 *
 *  @returns GTLRComputeQuery_InstancesStop
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Deletes the specified instance template. If you delete an instance template
 *  that is being referenced from another instance group, the instance group
 *  will not be able to create or recreate virtual machine instances. Deleting
 *  an instance template is permanent and cannot be undone.
 *
 *  Method: compute.instanceTemplates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesDeleteWithproject:instanceTemplate:]

/** The name of the instance template to delete. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance template. If you delete an instance template
 *  that is being referenced from another instance group, the instance group
 *  will not be able to create or recreate virtual machine instances. Deleting
 *  an instance template is permanent and cannot be undone.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template to delete.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Returns the specified instance template. Get a list of available instance
 *  templates by making a list() request.
 *
 *  Method: compute.instanceTemplates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesGetWithproject:instanceTemplate:]

/** The name of the instance template. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplate.
 *
 *  Returns the specified instance template. Get a list of available instance
 *  templates by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  Method: compute.instanceTemplates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  @param object The @c GTLRCompute_InstanceTemplate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceTemplate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of instance templates that are contained within the
 *  specified project and zone.
 *
 *  Method: compute.instanceTemplates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplateList.
 *
 *  Retrieves a list of instance templates that are contained within the
 *  specified project and zone.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified License resource.
 *
 *  Method: compute.licenses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesGetWithproject:license:]

/** Name of the License resource to return. */
@property(nonatomic, copy, nullable) NSString *license;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_License.
 *
 *  Returns the specified License resource.
 *
 *  @param project Project ID for this request.
 *  @param license Name of the License resource to return.
 *
 *  @returns GTLRComputeQuery_LicensesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         license:(NSString *)license;

@end

/**
 *  Retrieves an aggregated list of machine types.
 *
 *  Method: compute.machineTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_MachineTypeAggregatedList.
 *
 *  Retrieves an aggregated list of machine types.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_MachineTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified machine type. Get a list of available machine types by
 *  making a list() request.
 *
 *  Method: compute.machineTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesGetWithproject:zoneProperty:machineType:]

/** Name of the machine type to return. */
@property(nonatomic, copy, nullable) NSString *machineType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineType.
 *
 *  Returns the specified machine type. Get a list of available machine types by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param machineType Name of the machine type to return.
 *
 *  @returns GTLRComputeQuery_MachineTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     machineType:(NSString *)machineType;

@end

/**
 *  Retrieves a list of machine types available to the specified project.
 *
 *  Method: compute.machineTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineTypeList.
 *
 *  Retrieves a list of machine types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_MachineTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Adds a peering to the specified network.
 *
 *  Method: compute.networks.addPeering
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksAddPeering : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksAddPeeringWithObject:project:network:]

/** Name of the network resource to add peering to. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a peering to the specified network.
 *
 *  @param object The @c GTLRCompute_NetworksAddPeeringRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param network Name of the network resource to add peering to.
 *
 *  @returns GTLRComputeQuery_NetworksAddPeering
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworksAddPeeringRequest *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Deletes the specified network.
 *
 *  Method: compute.networks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksDeleteWithproject:network:]

/** Name of the network to delete. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to delete.
 *
 *  @returns GTLRComputeQuery_NetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Returns the specified network. Get a list of available networks by making a
 *  list() request.
 *
 *  Method: compute.networks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksGetWithproject:network:]

/** Name of the network to return. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Network.
 *
 *  Returns the specified network. Get a list of available networks by making a
 *  list() request.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to return.
 *
 *  @returns GTLRComputeQuery_NetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.networks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Network to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_NetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Network *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of networks available to the specified project.
 *
 *  Method: compute.networks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NetworkList.
 *
 *  Retrieves the list of networks available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_NetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified network with the data included in the request.
 *
 *  Method: compute.networks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksPatchWithObject:project:network:]

/** Name of the network to update. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified network with the data included in the request.
 *
 *  @param object The @c GTLRCompute_Network to include in the query.
 *  @param project Project ID for this request.
 *  @param network Name of the network to update.
 *
 *  @returns GTLRComputeQuery_NetworksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Network *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Removes a peering from the specified network.
 *
 *  Method: compute.networks.removePeering
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksRemovePeering : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksRemovePeeringWithObject:project:network:]

/** Name of the network resource to remove peering from. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes a peering from the specified network.
 *
 *  @param object The @c GTLRCompute_NetworksRemovePeeringRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param network Name of the network resource to remove peering from.
 *
 *  @returns GTLRComputeQuery_NetworksRemovePeering
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworksRemovePeeringRequest *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Switches the network mode from auto subnet mode to custom subnet mode.
 *
 *  Method: compute.networks.switchToCustomMode
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksSwitchToCustomMode : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksSwitchToCustomModeWithproject:network:]

/** Name of the network to be updated. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Switches the network mode from auto subnet mode to custom subnet mode.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to be updated.
 *
 *  @returns GTLRComputeQuery_NetworksSwitchToCustomMode
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Disable this project as a shared VPC host project.
 *
 *  Method: compute.projects.disableXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsDisableXpnHost : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsDisableXpnHostWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Disable this project as a shared VPC host project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsDisableXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Disable a serivce resource (a.k.a service project) associated with this host
 *  project.
 *
 *  Method: compute.projects.disableXpnResource
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsDisableXpnResource : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsDisableXpnResourceWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Disable a serivce resource (a.k.a service project) associated with this host
 *  project.
 *
 *  @param object The @c GTLRCompute_ProjectsDisableXpnResourceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsDisableXpnResource
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsDisableXpnResourceRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Enable this project as a shared VPC host project.
 *
 *  Method: compute.projects.enableXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsEnableXpnHost : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsEnableXpnHostWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enable this project as a shared VPC host project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsEnableXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Enable service resource (a.k.a service project) for a host project, so that
 *  subnets in the host project can be used by instances in the service project.
 *
 *  Method: compute.projects.enableXpnResource
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsEnableXpnResource : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsEnableXpnResourceWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enable service resource (a.k.a service project) for a host project, so that
 *  subnets in the host project can be used by instances in the service project.
 *
 *  @param object The @c GTLRCompute_ProjectsEnableXpnResourceRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsEnableXpnResource
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsEnableXpnResourceRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Returns the specified Project resource.
 *
 *  Method: compute.projects.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ProjectsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsGetWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Project.
 *
 *  Returns the specified Project resource.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsGet
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Get the shared VPC host project that this project links to. May be empty if
 *  no link exists.
 *
 *  Method: compute.projects.getXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsGetXpnHost : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsGetXpnHostWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Project.
 *
 *  Get the shared VPC host project that this project links to. May be empty if
 *  no link exists.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsGetXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Get service resources (a.k.a service project) associated with this host
 *  project.
 *
 *  Method: compute.projects.getXpnResources
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsGetXpnResources : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsGetXpnResourcesWithproject:]

@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  maxResults
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

@property(nonatomic, copy, nullable) NSString *orderBy;

@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ProjectsGetXpnResources.
 *
 *  Get service resources (a.k.a service project) associated with this host
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsGetXpnResources
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  List all shared VPC host projects visible to the user in an organization.
 *
 *  Method: compute.projects.listXpnHosts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsListXpnHosts : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsListXpnHostsWithObject:project:]

@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  maxResults
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

@property(nonatomic, copy, nullable) NSString *orderBy;

@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_XpnHostList.
 *
 *  List all shared VPC host projects visible to the user in an organization.
 *
 *  @param object The @c GTLRCompute_ProjectsListXpnHostsRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsListXpnHosts
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsListXpnHostsRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Moves a persistent disk from one zone to another.
 *
 *  Method: compute.projects.moveDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsMoveDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsMoveDiskWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves a persistent disk from one zone to another.
 *
 *  @param object The @c GTLRCompute_DiskMoveRequest to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsMoveDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_DiskMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Moves an instance and its attached persistent disks from one zone to
 *  another.
 *
 *  Method: compute.projects.moveInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsMoveInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsMoveInstanceWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves an instance and its attached persistent disks from one zone to
 *  another.
 *
 *  @param object The @c GTLRCompute_InstanceMoveRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsMoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  Method: compute.projects.setCommonInstanceMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsSetCommonInstanceMetadata : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsSetCommonInstanceMetadataWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsSetCommonInstanceMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project;

@end

/**
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  Method: compute.projects.setUsageExportBucket
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ProjectsSetUsageExportBucket : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsSetUsageExportBucketWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  @param object The @c GTLRCompute_UsageExportLocation to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsSetUsageExportBucket
 */
+ (instancetype)queryWithObject:(GTLRCompute_UsageExportLocation *)object
                        project:(NSString *)project;

@end

/**
 *  Deletes the specified autoscaler.
 *
 *  Method: compute.regionAutoscalers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersDeleteWithproject:region:autoscaler:]

/** Name of the autoscaler to delete. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param autoscaler Name of the autoscaler to delete.
 *
 *  @returns GTLRComputeQuery_RegionAutoscalersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Returns the specified autoscaler.
 *
 *  Method: compute.regionAutoscalers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionAutoscalersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersGetWithproject:region:autoscaler:]

/** Name of the autoscaler to return. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Autoscaler.
 *
 *  Returns the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param autoscaler Name of the autoscaler to return.
 *
 *  @returns GTLRComputeQuery_RegionAutoscalersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.regionAutoscalers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionAutoscalersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of autoscalers contained within the specified region.
 *
 *  Method: compute.regionAutoscalers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionAutoscalersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionAutoscalerList.
 *
 *  Retrieves a list of autoscalers contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionAutoscalersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.regionAutoscalers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersPatchWithObject:project:region:]

/** Name of the autoscaler to patch. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionAutoscalersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.regionAutoscalers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersUpdateWithObject:project:region:]

/** Name of the autoscaler to update. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionAutoscalersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Deletes the specified regional BackendService resource.
 *
 *  Method: compute.regionBackendServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesDeleteWithproject:region:backendService:]

/** Name of the BackendService resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified regional BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to delete.
 *
 *  @returns GTLRComputeQuery_RegionBackendServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  backendService:(NSString *)backendService;

@end

/**
 *  Returns the specified regional BackendService resource.
 *
 *  Method: compute.regionBackendServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesGetWithproject:region:backendService:]

/** Name of the BackendService resource to return. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendService.
 *
 *  Returns the specified regional BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to return.
 *
 *  @returns GTLRComputeQuery_RegionBackendServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  backendService:(NSString *)backendService;

@end

/**
 *  Gets the most recent health check results for this regional BackendService.
 *
 *  Method: compute.regionBackendServices.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesGetHealthWithObject:project:region:backendService:]

/**
 *  Name of the BackendService resource to which the queried instance belongs.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendServiceGroupHealth.
 *
 *  Gets the most recent health check results for this regional BackendService.
 *
 *  @param object The @c GTLRCompute_ResourceGroupReference to include in the
 *    query.
 *  @param project NSString
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to which the
 *    queried instance belongs.
 *
 *  @returns GTLRComputeQuery_RegionBackendServicesGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourceGroupReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Creates a regional BackendService resource in the specified project using
 *  the data included in the request. There are several restrictions and
 *  guidelines to keep in mind when creating a regional backend service. Read
 *  Restrictions and Guidelines for more information.
 *
 *  Method: compute.regionBackendServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a regional BackendService resource in the specified project using
 *  the data included in the request. There are several restrictions and
 *  guidelines to keep in mind when creating a regional backend service. Read
 *  Restrictions and Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionBackendServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of regional BackendService resources available to the
 *  specified project in the given region.
 *
 *  Method: compute.regionBackendServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendServiceList.
 *
 *  Retrieves the list of regional BackendService resources available to the
 *  specified project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionBackendServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information. This method supports PATCH semantics and
 *  uses the JSON merge patch format and processing rules.
 *
 *  Method: compute.regionBackendServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesPatchWithObject:project:region:backendService:]

/** Name of the BackendService resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information. This method supports PATCH semantics and
 *  uses the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to patch.
 *
 *  @returns GTLRComputeQuery_RegionBackendServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  Method: compute.regionBackendServices.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesUpdateWithObject:project:region:backendService:]

/** Name of the BackendService resource to update. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @returns GTLRComputeQuery_RegionBackendServicesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves an aggregated list of commitments.
 *
 *  Method: compute.regionCommitments.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_CommitmentAggregatedList.
 *
 *  Retrieves an aggregated list of commitments.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RegionCommitmentsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified commitment resource. Get a list of available
 *  commitments by making a list() request.
 *
 *  Method: compute.regionCommitments.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsGetWithproject:region:commitment:]

/** Name of the commitment to return. */
@property(nonatomic, copy, nullable) NSString *commitment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Commitment.
 *
 *  Returns the specified commitment resource. Get a list of available
 *  commitments by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param commitment Name of the commitment to return.
 *
 *  @returns GTLRComputeQuery_RegionCommitmentsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      commitment:(NSString *)commitment;

@end

/**
 *  Creates a commitment in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.regionCommitments.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionCommitmentsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a commitment in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Commitment to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_RegionCommitmentsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Commitment *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of commitments contained within the specified region.
 *
 *  Method: compute.regionCommitments.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_CommitmentList.
 *
 *  Retrieves a list of commitments contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_RegionCommitmentsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Schedules a group action to remove the specified instances from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.abandonInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersAbandonInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersAbandonInstancesWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to remove the specified instances from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersAbandonInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Deletes the specified managed instance group and all of the instances in
 *  that group.
 *
 *  Method: compute.regionInstanceGroupManagers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersDeleteWithproject:region:instanceGroupManager:]

/** Name of the managed instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified managed instance group and all of the instances in
 *  that group.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group to delete.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Schedules a group action to delete the specified instances in the managed
 *  instance group. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. This operation is
 *  marked as DONE when the action is scheduled even if the instances are still
 *  being deleted. You must separately verify the status of the deleting action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.deleteInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersDeleteInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersDeleteInstancesWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to delete the specified instances in the managed
 *  instance group. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. This operation is
 *  marked as DONE when the action is scheduled even if the instances are still
 *  being deleted. You must separately verify the status of the deleting action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersDeleteInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns all of the details about the specified managed instance group.
 *
 *  Method: compute.regionInstanceGroupManagers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersGetWithproject:region:instanceGroupManager:]

/** Name of the managed instance group to return. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManager.
 *
 *  Returns all of the details about the specified managed instance group.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group to return.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, it schedules an action to create
 *  instances in the group using the specified instance template. This operation
 *  is marked as DONE when the group is created even if the instances in the
 *  group have not yet been created. You must separately verify the status of
 *  the individual instances with the listmanagedinstances method.
 *  A regional managed instance group can contain up to 2000 instances.
 *
 *  Method: compute.regionInstanceGroupManagers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, it schedules an action to create
 *  instances in the group using the specified instance template. This operation
 *  is marked as DONE when the group is created even if the instances in the
 *  group have not yet been created. You must separately verify the status of
 *  the individual instances with the listmanagedinstances method.
 *  A regional managed instance group can contain up to 2000 instances.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of managed instance groups that are contained within the
 *  specified region.
 *
 *  Method: compute.regionInstanceGroupManagers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagerList.
 *
 *  Retrieves the list of managed instance groups that are contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists the instances in the managed instance group and instances that are
 *  scheduled to be created. The list includes any current actions that the
 *  group has scheduled for its instances.
 *
 *  Method: compute.regionInstanceGroupManagers.listManagedInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersListManagedInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersListManagedInstancesWithproject:region:instanceGroupManager:]

@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  maxResults
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

@property(nonatomic, copy, nullable) NSString *orderBy;

@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagersListInstancesResponse.
 *
 *  Lists the instances in the managed instance group and instances that are
 *  scheduled to be created. The list includes any current actions that the
 *  group has scheduled for its instances.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersListManagedInstances
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Schedules a group action to recreate the specified instances in the managed
 *  instance group. The instances are deleted and recreated using the current
 *  instance template for the managed instance group. This operation is marked
 *  as DONE when the action is scheduled even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.recreateInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersRecreateInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersRecreateInstancesWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to recreate the specified instances in the managed
 *  instance group. The instances are deleted and recreated using the current
 *  instance template for the managed instance group. This operation is marked
 *  as DONE when the action is scheduled even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupManagersRecreateRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersRecreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersRecreateRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Changes the intended size for the managed instance group. If you increase
 *  the size, the group schedules actions to create new instances using the
 *  current instance template. If you decrease the size, the group schedules
 *  delete actions on one or more instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  Method: compute.regionInstanceGroupManagers.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersResizeWithproject:region:instanceGroupManager:size:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Number of instances that should exist in this instance group manager. */
@property(nonatomic, assign) NSInteger size;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the intended size for the managed instance group. If you increase
 *  the size, the group schedules actions to create new instances using the
 *  current instance template. If you decrease the size, the group schedules
 *  delete actions on one or more instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *  @param size Number of instances that should exist in this instance group
 *    manager.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersResize
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager
                            size:(NSInteger)size;

@end

/**
 *  Sets the instance template to use when creating new instances or recreating
 *  instances in this group. Existing instances are not affected.
 *
 *  Method: compute.regionInstanceGroupManagers.setInstanceTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersSetInstanceTemplate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersSetInstanceTemplateWithObject:project:region:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the instance template to use when creating new instances or recreating
 *  instances in this group. Existing instances are not affected.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersSetInstanceTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Modifies the target pools to which all new instances in this group are
 *  assigned. Existing instances in the group are not affected.
 *
 *  Method: compute.regionInstanceGroupManagers.setTargetPools
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersSetTargetPools : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersSetTargetPoolsWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modifies the target pools to which all new instances in this group are
 *  assigned. Existing instances in the group are not affected.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupManagersSetTargetPools
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns the specified instance group resource.
 *
 *  Method: compute.regionInstanceGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsGetWithproject:region:instanceGroup:]

/** Name of the instance group resource to return. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstanceGroup.
 *
 *  Returns the specified instance group resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup Name of the instance group resource to return.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Retrieves the list of instance group resources contained within the
 *  specified region.
 *
 *  Method: compute.regionInstanceGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupList.
 *
 *  Retrieves the list of instance group resources contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists the instances in the specified instance group and displays information
 *  about the named ports. Depending on the specified options, this method can
 *  list all instances or only the instances that are running.
 *
 *  Method: compute.regionInstanceGroups.listInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsListInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsListInstancesWithObject:project:region:instanceGroup:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Name of the regional instance group for which we want to list the instances.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupsListInstances.
 *
 *  Lists the instances in the specified instance group and displays information
 *  about the named ports. Depending on the specified options, this method can
 *  list all instances or only the instances that are running.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupsListInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup Name of the regional instance group for which we want
 *    to list the instances.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupsListInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupsListInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Sets the named ports for the specified regional instance group.
 *
 *  Method: compute.regionInstanceGroups.setNamedPorts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupsSetNamedPorts : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsSetNamedPortsWithObject:project:region:instanceGroup:]

/**
 *  The name of the regional instance group where the named ports are updated.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the named ports for the specified regional instance group.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup The name of the regional instance group where the named
 *    ports are updated.
 *
 *  @returns GTLRComputeQuery_RegionInstanceGroupsSetNamedPorts
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Deletes the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsDeleteWithproject:region:operation:]

/** Name of the Operations resource to delete. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @returns GTLRComputeQuery_RegionOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsGetWithproject:region:operation:]

/** Name of the Operations resource to return. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @returns GTLRComputeQuery_RegionOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  Method: compute.regionOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_RegionOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Returns the specified Region resource. Get a list of available regions by
 *  making a list() request.
 *
 *  Method: compute.regions.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionsGetWithproject:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region resource to return. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Region.
 *
 *  Returns the specified Region resource. Get a list of available regions by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region resource to return.
 *
 *  @returns GTLRComputeQuery_RegionsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves the list of region resources available to the specified project.
 *
 *  Method: compute.regions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionsListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RegionList.
 *
 *  Retrieves the list of region resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RegionsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Retrieves an aggregated list of routers.
 *
 *  Method: compute.routers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RouterAggregatedList.
 *
 *  Retrieves an aggregated list of routers.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RoutersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Router resource.
 *
 *  Method: compute.routers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersDeleteWithproject:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to delete. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Router resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to delete.
 *
 *  @returns GTLRComputeQuery_RoutersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Returns the specified Router resource. Get a list of available routers by
 *  making a list() request.
 *
 *  Method: compute.routers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersGetWithproject:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to return. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Router.
 *
 *  Returns the specified Router resource. Get a list of available routers by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to return.
 *
 *  @returns GTLRComputeQuery_RoutersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Retrieves runtime information of the specified router.
 *
 *  Method: compute.routers.getRouterStatus
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGetRouterStatus : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersGetRouterStatusWithproject:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to query. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_RouterStatusResponse.
 *
 *  Retrieves runtime information of the specified router.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query.
 *
 *  @returns GTLRComputeQuery_RoutersGetRouterStatus
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Creates a Router resource in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.routers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Router resource in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_RoutersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of Router resources available to the specified project.
 *
 *  Method: compute.routers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RouterList.
 *
 *  Retrieves a list of Router resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_RoutersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  Method: compute.routers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersPatchWithObject:project:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to patch. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to patch.
 *
 *  @returns GTLRComputeQuery_RoutersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Preview fields auto-generated during router create and update operations.
 *  Calling this method does NOT create or update the router.
 *
 *  Method: compute.routers.preview
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersPreview : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersPreviewWithObject:project:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to query. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_RoutersPreviewResponse.
 *
 *  Preview fields auto-generated during router create and update operations.
 *  Calling this method does NOT create or update the router.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query.
 *
 *  @returns GTLRComputeQuery_RoutersPreview
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Updates the specified Router resource with the data included in the request.
 *
 *  Method: compute.routers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersUpdateWithObject:project:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to update. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified Router resource with the data included in the request.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to update.
 *
 *  @returns GTLRComputeQuery_RoutersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Deletes the specified Route resource.
 *
 *  Method: compute.routes.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesDeleteWithproject:route:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Route resource to delete. */
@property(nonatomic, copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Route resource.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to delete.
 *
 *  @returns GTLRComputeQuery_RoutesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Returns the specified Route resource. Get a list of available routes by
 *  making a list() request.
 *
 *  Method: compute.routes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesGetWithproject:route:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the Route resource to return. */
@property(nonatomic, copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Route.
 *
 *  Returns the specified Route resource. Get a list of available routes by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to return.
 *
 *  @returns GTLRComputeQuery_RoutesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.routes.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Route to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RoutesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Route *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  Method: compute.routes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RouteList.
 *
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RoutesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot.
 *  For more information, see Deleting snaphots.
 *
 *  Method: compute.snapshots.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsDeleteWithproject:snapshot:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Snapshot resource to delete. */
@property(nonatomic, copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot.
 *  For more information, see Deleting snaphots.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to delete.
 *
 *  @returns GTLRComputeQuery_SnapshotsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Returns the specified Snapshot resource. Get a list of available snapshots
 *  by making a list() request.
 *
 *  Method: compute.snapshots.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsGetWithproject:snapshot:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the Snapshot resource to return. */
@property(nonatomic, copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Snapshot.
 *
 *  Returns the specified Snapshot resource. Get a list of available snapshots
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to return.
 *
 *  @returns GTLRComputeQuery_SnapshotsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  Method: compute.snapshots.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SnapshotList.
 *
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SnapshotsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the labels on a snapshot. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.snapshots.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsSetLabelsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a snapshot. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name of the resource for this request.
 *
 *  @returns GTLRComputeQuery_SnapshotsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified SslCertificate resource.
 *
 *  Method: compute.sslCertificates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesDeleteWithproject:sslCertificate:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the SslCertificate resource to delete. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SslCertificate resource.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to delete.
 *
 *  @returns GTLRComputeQuery_SslCertificatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Returns the specified SslCertificate resource. Get a list of available SSL
 *  certificates by making a list() request.
 *
 *  Method: compute.sslCertificates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesGetWithproject:sslCertificate:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the SslCertificate resource to return. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_SslCertificate.
 *
 *  Returns the specified SslCertificate resource. Get a list of available SSL
 *  certificates by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to return.
 *
 *  @returns GTLRComputeQuery_SslCertificatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.sslCertificates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_SslCertificate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SslCertificatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslCertificate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  Method: compute.sslCertificates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SslCertificateList.
 *
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SslCertificatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Retrieves an aggregated list of subnetworks.
 *
 *  Method: compute.subnetworks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SubnetworkAggregatedList.
 *
 *  Retrieves an aggregated list of subnetworks.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SubnetworksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified subnetwork.
 *
 *  Method: compute.subnetworks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksDeleteWithproject:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to delete. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified subnetwork.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to delete.
 *
 *  @returns GTLRComputeQuery_SubnetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Expands the IP CIDR range of the subnetwork to a specified value.
 *
 *  Method: compute.subnetworks.expandIpCidrRange
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksExpandIpCidrRange : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksExpandIpCidrRangeWithObject:project:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to update. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Expands the IP CIDR range of the subnetwork to a specified value.
 *
 *  @param object The @c GTLRCompute_SubnetworksExpandIpCidrRangeRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to update.
 *
 *  @returns GTLRComputeQuery_SubnetworksExpandIpCidrRange
 */
+ (instancetype)queryWithObject:(GTLRCompute_SubnetworksExpandIpCidrRangeRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Returns the specified subnetwork. Get a list of available subnetworks list()
 *  request.
 *
 *  Method: compute.subnetworks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksGetWithproject:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Subnetwork resource to return. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Subnetwork.
 *
 *  Returns the specified subnetwork. Get a list of available subnetworks list()
 *  request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to return.
 *
 *  @returns GTLRComputeQuery_SubnetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.subnetworks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Subnetwork to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_SubnetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Subnetwork *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  Method: compute.subnetworks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_SubnetworkList.
 *
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_SubnetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Set whether VMs in this subnet can access Google services without assigning
 *  external IP addresses through Private Google Access.
 *
 *  Method: compute.subnetworks.setPrivateIpGoogleAccess
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksSetPrivateIpGoogleAccess : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksSetPrivateIpGoogleAccessWithObject:project:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Set whether VMs in this subnet can access Google services without assigning
 *  external IP addresses through Private Google Access.
 *
 *  @param object The @c GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource.
 *
 *  @returns GTLRComputeQuery_SubnetworksSetPrivateIpGoogleAccess
 */
+ (instancetype)queryWithObject:(GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  Method: compute.targetHttpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesDeleteWithproject:targetHttpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Returns the specified TargetHttpProxy resource. Get a list of available
 *  target HTTP proxies by making a list() request.
 *
 *  Method: compute.targetHttpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesGetWithproject:targetHttpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetHttpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxy.
 *
 *  Returns the specified TargetHttpProxy resource. Get a list of available
 *  target HTTP proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to return.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxyList.
 *
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the URL map for TargetHttpProxy.
 *
 *  Method: compute.targetHttpProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesSetUrlMap : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesSetUrlMapWithObject:project:targetHttpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy to set a URL map for. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy to set a URL map for.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
                targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  Method: compute.targetHttpsProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesDeleteWithproject:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Returns the specified TargetHttpsProxy resource. Get a list of available
 *  target HTTPS proxies by making a list() request.
 *
 *  Method: compute.targetHttpsProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesGetWithproject:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetHttpsProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxy.
 *
 *  Returns the specified TargetHttpsProxy resource. Get a list of available
 *  target HTTPS proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to return.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpsProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpsProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxyList.
 *
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetSslCertificatesWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource to set an SslCertificates resource
 *  for.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to set an
 *    SslCertificates resource for.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetUrlMap : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetUrlMapWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource whose URL map is to be set. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource whose URL map
 *    is to be set.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Retrieves an aggregated list of target instances.
 *
 *  Method: compute.targetInstances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceAggregatedList.
 *
 *  Retrieves an aggregated list of target instances.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetInstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified TargetInstance resource.
 *
 *  Method: compute.targetInstances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesDeleteWithproject:zoneProperty:targetInstance:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetInstance resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetInstance resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetInstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Returns the specified TargetInstance resource. Get a list of available
 *  target instances by making a list() request.
 *
 *  Method: compute.targetInstances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesGetWithproject:zoneProperty:targetInstance:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetInstance resource to return. */
@property(nonatomic, copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstance.
 *
 *  Returns the specified TargetInstance resource. Get a list of available
 *  target instances by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to return.
 *
 *  @returns GTLRComputeQuery_TargetInstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  Method: compute.targetInstances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetInstance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetInstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetInstance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  Method: compute.targetInstances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceList.
 *
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetInstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Adds health check URLs to a target pool.
 *
 *  Method: compute.targetPools.addHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddHealthCheck : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAddHealthCheckWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target pool to add a health check to. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds health check URLs to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddHealthCheckRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the target pool to add a health check to.
 *
 *  @returns GTLRComputeQuery_TargetPoolsAddHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Adds an instance to a target pool.
 *
 *  Method: compute.targetPools.addInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAddInstanceWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to add instances to. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an instance to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddInstanceRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to add instances to.
 *
 *  @returns GTLRComputeQuery_TargetPoolsAddInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Retrieves an aggregated list of target pools.
 *
 *  Method: compute.targetPools.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetPoolAggregatedList.
 *
 *  Retrieves an aggregated list of target pools.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetPoolsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target pool.
 *
 *  Method: compute.targetPools.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsDeleteWithproject:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target pool.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetPoolsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Returns the specified target pool. Get a list of available target pools by
 *  making a list() request.
 *
 *  Method: compute.targetPools.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsGetWithproject:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetPool resource to return. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPool.
 *
 *  Returns the specified target pool. Get a list of available target pools by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to return.
 *
 *  @returns GTLRComputeQuery_TargetPoolsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  Method: compute.targetPools.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsGetHealthWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetPool resource to which the queried instance belongs. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPoolInstanceHealth.
 *
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  @param object The @c GTLRCompute_InstanceReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to which the queried
 *    instance belongs.
 *
 *  @returns GTLRComputeQuery_TargetPoolsGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.targetPools.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetPool to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetPoolsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPool *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  Method: compute.targetPools.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_TargetPoolList.
 *
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetPoolsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Removes health check URL from a target pool.
 *
 *  Method: compute.targetPools.removeHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveHealthCheck : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsRemoveHealthCheckWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target pool to remove health checks from. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes health check URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveHealthCheckRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetPool Name of the target pool to remove health checks from.
 *
 *  @returns GTLRComputeQuery_TargetPoolsRemoveHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Removes instance URL from a target pool.
 *
 *  Method: compute.targetPools.removeInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsRemoveInstanceWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to remove instances from. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes instance URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveInstanceRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to remove instances from.
 *
 *  @returns GTLRComputeQuery_TargetPoolsRemoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Changes a backup target pool's configurations.
 *
 *  Method: compute.targetPools.setBackup
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsSetBackup : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsSetBackupWithObject:project:region:targetPool:]

/** New failoverRatio value for the target pool. */
@property(nonatomic, assign) float failoverRatio;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to set a backup pool for. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes a backup target pool's configurations.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to set a backup pool for.
 *
 *  @returns GTLRComputeQuery_TargetPoolsSetBackup
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Deletes the specified TargetSslProxy resource.
 *
 *  Method: compute.targetSslProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesDeleteWithproject:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetSslProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetSslProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetSslProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Returns the specified TargetSslProxy resource. Get a list of available
 *  target SSL proxies by making a list() request.
 *
 *  Method: compute.targetSslProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetSslProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesGetWithproject:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetSslProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_TargetSslProxy.
 *
 *  Returns the specified TargetSslProxy resource. Get a list of available
 *  target SSL proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource to return.
 *
 *  @returns GTLRComputeQuery_TargetSslProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Creates a TargetSslProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetSslProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetSslProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetSslProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetSslProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetSslProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetSslProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetSslProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetSslProxyList.
 *
 *  Retrieves the list of TargetSslProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetSslProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the BackendService for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setBackendService
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetBackendService : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesSetBackendServiceWithObject:project:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose BackendService resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the BackendService for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetBackendServiceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose
 *    BackendService resource is to be set.
 *
 *  @returns GTLRComputeQuery_TargetSslProxiesSetBackendService
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetBackendServiceRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Changes the ProxyHeaderType for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setProxyHeader
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetProxyHeader : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesSetProxyHeaderWithObject:project:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetSslProxy resource whose ProxyHeader is to be set. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the ProxyHeaderType for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetProxyHeaderRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose ProxyHeader
 *    is to be set.
 *
 *  @returns GTLRComputeQuery_TargetSslProxiesSetProxyHeader
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetProxyHeaderRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Changes SslCertificates for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetSslCertificates : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesSetSslCertificatesWithObject:project:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose SslCertificate resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes SslCertificates for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetSslCertificatesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose
 *    SslCertificate resource is to be set.
 *
 *  @returns GTLRComputeQuery_TargetSslProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  Method: compute.targetTcpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesDeleteWithproject:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetTcpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetTcpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Returns the specified TargetTcpProxy resource. Get a list of available
 *  target TCP proxies by making a list() request.
 *
 *  Method: compute.targetTcpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetTcpProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesGetWithproject:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetTcpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxy.
 *
 *  Returns the specified TargetTcpProxy resource. Get a list of available
 *  target TCP proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to return.
 *
 *  @returns GTLRComputeQuery_TargetTcpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Creates a TargetTcpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetTcpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetTcpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetTcpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetTcpProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetTcpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetTcpProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxyList.
 *
 *  Retrieves the list of TargetTcpProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetTcpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the BackendService for TargetTcpProxy.
 *
 *  Method: compute.targetTcpProxies.setBackendService
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesSetBackendService : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesSetBackendServiceWithObject:project:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetTcpProxy resource whose BackendService resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the BackendService for TargetTcpProxy.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxiesSetBackendServiceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource whose
 *    BackendService resource is to be set.
 *
 *  @returns GTLRComputeQuery_TargetTcpProxiesSetBackendService
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxiesSetBackendServiceRequest *)object
                        project:(NSString *)project
                 targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Changes the ProxyHeaderType for TargetTcpProxy.
 *
 *  Method: compute.targetTcpProxies.setProxyHeader
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesSetProxyHeader : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesSetProxyHeaderWithObject:project:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetTcpProxy resource whose ProxyHeader is to be set. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the ProxyHeaderType for TargetTcpProxy.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource whose ProxyHeader
 *    is to be set.
 *
 *  @returns GTLRComputeQuery_TargetTcpProxiesSetProxyHeader
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest *)object
                        project:(NSString *)project
                 targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Retrieves an aggregated list of target VPN gateways.
 *
 *  Method: compute.targetVpnGateways.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayAggregatedList.
 *
 *  Retrieves an aggregated list of target VPN gateways.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target VPN gateway.
 *
 *  Method: compute.targetVpnGateways.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysDeleteWithproject:region:targetVpnGateway:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target VPN gateway to delete. */
@property(nonatomic, copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to delete.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Returns the specified target VPN gateway. Get a list of available target VPN
 *  gateways by making a list() request.
 *
 *  Method: compute.targetVpnGateways.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysGetWithproject:region:targetVpnGateway:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the target VPN gateway to return. */
@property(nonatomic, copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGateway.
 *
 *  Returns the specified target VPN gateway. Get a list of available target VPN
 *  gateways by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to return.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.targetVpnGateways.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetVpnGateway to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetVpnGateway *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  Method: compute.targetVpnGateways.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayList.
 *
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified UrlMap resource.
 *
 *  Method: compute.urlMaps.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsDeleteWithproject:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to delete. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified UrlMap resource.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to delete.
 *
 *  @returns GTLRComputeQuery_UrlMapsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Returns the specified UrlMap resource. Get a list of available URL maps by
 *  making a list() request.
 *
 *  Method: compute.urlMaps.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsGetWithproject:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the UrlMap resource to return. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMap.
 *
 *  Returns the specified UrlMap resource. Get a list of available URL maps by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to return.
 *
 *  @returns GTLRComputeQuery_UrlMapsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.urlMaps.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_UrlMapsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project;

@end

/**
 *  Initiates a cache invalidation operation, invalidating the specified path,
 *  scoped to the specified UrlMap.
 *
 *  Method: compute.urlMaps.invalidateCache
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsInvalidateCache : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsInvalidateCacheWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap scoping this request. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Initiates a cache invalidation operation, invalidating the specified path,
 *  scoped to the specified UrlMap.
 *
 *  @param object The @c GTLRCompute_CacheInvalidationRule to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap scoping this request.
 *
 *  @returns GTLRComputeQuery_UrlMapsInvalidateCache
 */
+ (instancetype)queryWithObject:(GTLRCompute_CacheInvalidationRule *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  Method: compute.urlMaps.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_UrlMapList.
 *
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_UrlMapsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.urlMaps.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsPatchWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to patch. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to patch.
 *
 *  @returns GTLRComputeQuery_UrlMapsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  Method: compute.urlMaps.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsUpdateWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to update. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to update.
 *
 *  @returns GTLRComputeQuery_UrlMapsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  Method: compute.urlMaps.validate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsValidate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsValidateWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the UrlMap resource to be validated as. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMapsValidateResponse.
 *
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  @param object The @c GTLRCompute_UrlMapsValidateRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to be validated as.
 *
 *  @returns GTLRComputeQuery_UrlMapsValidate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapsValidateRequest *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves an aggregated list of VPN tunnels.
 *
 *  Method: compute.vpnTunnels.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsAggregatedListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelAggregatedList.
 *
 *  Retrieves an aggregated list of VPN tunnels.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified VpnTunnel resource.
 *
 *  Method: compute.vpnTunnels.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsDeleteWithproject:region:vpnTunnel:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the VpnTunnel resource to delete. */
@property(nonatomic, copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified VpnTunnel resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to delete.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Returns the specified VpnTunnel resource. Get a list of available VPN
 *  tunnels by making a list() request.
 *
 *  Method: compute.vpnTunnels.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsGetWithproject:region:vpnTunnel:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the VpnTunnel resource to return. */
@property(nonatomic, copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_VpnTunnel.
 *
 *  Returns the specified VpnTunnel resource. Get a list of available VPN
 *  tunnels by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to return.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.vpnTunnels.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_VpnTunnel to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_VpnTunnel *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  Method: compute.vpnTunnels.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsListWithproject:region:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelList.
 *
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ZoneOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsDeleteWithproject:zoneProperty:operation:]

/** Name of the Operations resource to delete. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @returns GTLRComputeQuery_ZoneOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsGetWithproject:zoneProperty:operation:]

/** Name of the Operations resource to return. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @returns GTLRComputeQuery_ZoneOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  Method: compute.zoneOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsListWithproject:zoneProperty:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for request.
 *
 *  @returns GTLRComputeQuery_ZoneOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Returns the specified Zone resource. Get a list of available zones by making
 *  a list() request.
 *
 *  Method: compute.zones.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZonesGetWithproject:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone resource to return.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Zone.
 *
 *  Returns the specified Zone resource. Get a list of available zones by making
 *  a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone resource to return.
 *
 *  @returns GTLRComputeQuery_ZonesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  Method: compute.zones.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZonesListWithproject:]

/**
 *  Sets a filter {expression} for filtering listed resources. Your {expression}
 *  must be in the format: field_name comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use name ne example-instance.
 *  You can filter on nested fields. For example, you could filter on instances
 *  that have set the scheduling.automaticRestart field to true. Use filtering
 *  on nested fields to take advantage of labels to organize and search for
 *  results based on label values.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
 *  us-central1-f). Multiple expressions are treated as AND expressions, meaning
 *  that resources must match all expressions to pass the filters.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ZoneList.
 *
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ZonesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
