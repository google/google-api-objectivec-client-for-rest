// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Compute Engine API (compute/v1)
// Description:
//   Creates and runs virtual machines on Google Cloud Platform.
// Documentation:
//   https://developers.google.com/compute/docs/reference/latest/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRQuery.h"
#else
  #import "GTLRQuery.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCompute_AccessConfig;
@class GTLRCompute_Address;
@class GTLRCompute_AttachedDisk;
@class GTLRCompute_Autoscaler;
@class GTLRCompute_BackendBucket;
@class GTLRCompute_BackendService;
@class GTLRCompute_CacheInvalidationRule;
@class GTLRCompute_Commitment;
@class GTLRCompute_DeprecationStatus;
@class GTLRCompute_Disk;
@class GTLRCompute_DiskMoveRequest;
@class GTLRCompute_DisksResizeRequest;
@class GTLRCompute_Firewall;
@class GTLRCompute_ForwardingRule;
@class GTLRCompute_GlobalSetLabelsRequest;
@class GTLRCompute_GlobalSetPolicyRequest;
@class GTLRCompute_HealthCheck;
@class GTLRCompute_HttpHealthCheck;
@class GTLRCompute_HttpsHealthCheck;
@class GTLRCompute_Image;
@class GTLRCompute_Instance;
@class GTLRCompute_InstanceGroup;
@class GTLRCompute_InstanceGroupManager;
@class GTLRCompute_InstanceGroupManagersAbandonInstancesRequest;
@class GTLRCompute_InstanceGroupManagersDeleteInstancesRequest;
@class GTLRCompute_InstanceGroupManagersRecreateInstancesRequest;
@class GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest;
@class GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest;
@class GTLRCompute_InstanceGroupsAddInstancesRequest;
@class GTLRCompute_InstanceGroupsListInstancesRequest;
@class GTLRCompute_InstanceGroupsRemoveInstancesRequest;
@class GTLRCompute_InstanceGroupsSetNamedPortsRequest;
@class GTLRCompute_InstanceMoveRequest;
@class GTLRCompute_InstanceReference;
@class GTLRCompute_InstancesSetLabelsRequest;
@class GTLRCompute_InstancesSetMachineResourcesRequest;
@class GTLRCompute_InstancesSetMachineTypeRequest;
@class GTLRCompute_InstancesSetMinCpuPlatformRequest;
@class GTLRCompute_InstancesSetServiceAccountRequest;
@class GTLRCompute_InstancesStartWithEncryptionKeyRequest;
@class GTLRCompute_InstanceTemplate;
@class GTLRCompute_Interconnect;
@class GTLRCompute_InterconnectAttachment;
@class GTLRCompute_License;
@class GTLRCompute_Metadata;
@class GTLRCompute_Network;
@class GTLRCompute_NetworkInterface;
@class GTLRCompute_NetworksAddPeeringRequest;
@class GTLRCompute_NetworksRemovePeeringRequest;
@class GTLRCompute_NodeGroup;
@class GTLRCompute_NodeGroupsAddNodesRequest;
@class GTLRCompute_NodeGroupsDeleteNodesRequest;
@class GTLRCompute_NodeGroupsSetNodeTemplateRequest;
@class GTLRCompute_NodeTemplate;
@class GTLRCompute_ProjectsDisableXpnResourceRequest;
@class GTLRCompute_ProjectsEnableXpnResourceRequest;
@class GTLRCompute_ProjectsListXpnHostsRequest;
@class GTLRCompute_ProjectsSetDefaultNetworkTierRequest;
@class GTLRCompute_RegionDisksResizeRequest;
@class GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest;
@class GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest;
@class GTLRCompute_RegionInstanceGroupManagersRecreateRequest;
@class GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest;
@class GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest;
@class GTLRCompute_RegionInstanceGroupsListInstancesRequest;
@class GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest;
@class GTLRCompute_RegionSetLabelsRequest;
@class GTLRCompute_RegionSetPolicyRequest;
@class GTLRCompute_ResourceGroupReference;
@class GTLRCompute_Route;
@class GTLRCompute_Router;
@class GTLRCompute_Scheduling;
@class GTLRCompute_SecurityPolicy;
@class GTLRCompute_SecurityPolicyReference;
@class GTLRCompute_SecurityPolicyRule;
@class GTLRCompute_SignedUrlKey;
@class GTLRCompute_Snapshot;
@class GTLRCompute_SslCertificate;
@class GTLRCompute_SslPolicy;
@class GTLRCompute_SslPolicyReference;
@class GTLRCompute_Subnetwork;
@class GTLRCompute_SubnetworksExpandIpCidrRangeRequest;
@class GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest;
@class GTLRCompute_Tags;
@class GTLRCompute_TargetHttpProxy;
@class GTLRCompute_TargetHttpsProxiesSetQuicOverrideRequest;
@class GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest;
@class GTLRCompute_TargetHttpsProxy;
@class GTLRCompute_TargetInstance;
@class GTLRCompute_TargetPool;
@class GTLRCompute_TargetPoolsAddHealthCheckRequest;
@class GTLRCompute_TargetPoolsAddInstanceRequest;
@class GTLRCompute_TargetPoolsRemoveHealthCheckRequest;
@class GTLRCompute_TargetPoolsRemoveInstanceRequest;
@class GTLRCompute_TargetReference;
@class GTLRCompute_TargetSslProxiesSetBackendServiceRequest;
@class GTLRCompute_TargetSslProxiesSetProxyHeaderRequest;
@class GTLRCompute_TargetSslProxiesSetSslCertificatesRequest;
@class GTLRCompute_TargetSslProxy;
@class GTLRCompute_TargetTcpProxiesSetBackendServiceRequest;
@class GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest;
@class GTLRCompute_TargetTcpProxy;
@class GTLRCompute_TargetVpnGateway;
@class GTLRCompute_TestPermissionsRequest;
@class GTLRCompute_UrlMap;
@class GTLRCompute_UrlMapReference;
@class GTLRCompute_UrlMapsValidateRequest;
@class GTLRCompute_UsageExportLocation;
@class GTLRCompute_VpnTunnel;
@class GTLRCompute_ZoneSetLabelsRequest;
@class GTLRCompute_ZoneSetPolicyRequest;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

/**
 *  Parent class for other Compute query classes.
 */
@interface GTLRComputeQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(nonatomic, copy, nullable) NSString *fields;

@end

/**
 *  Retrieves an aggregated list of accelerator types.
 *
 *  Method: compute.acceleratorTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAcceleratorTypesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AcceleratorTypeAggregatedList.
 *
 *  Retrieves an aggregated list of accelerator types.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_AcceleratorTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified accelerator type.
 *
 *  Method: compute.acceleratorTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAcceleratorTypesGetWithproject:zoneProperty:acceleratorType:]

/** Name of the accelerator type to return. */
@property(nonatomic, copy, nullable) NSString *acceleratorType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AcceleratorType.
 *
 *  Returns the specified accelerator type.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param acceleratorType Name of the accelerator type to return.
 *
 *  @return GTLRComputeQuery_AcceleratorTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                 acceleratorType:(NSString *)acceleratorType;

@end

/**
 *  Retrieves a list of accelerator types available to the specified project.
 *
 *  Method: compute.acceleratorTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAcceleratorTypesListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AcceleratorTypeList.
 *
 *  Retrieves a list of accelerator types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AcceleratorTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves an aggregated list of addresses.
 *
 *  Method: compute.addresses.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AddressAggregatedList.
 *
 *  Retrieves an aggregated list of addresses.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_AddressesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.addresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesDeleteWithproject:region:address:]

/** Name of the address resource to delete. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @return GTLRComputeQuery_AddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource.
 *
 *  Method: compute.addresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesGetWithproject:region:address:]

/** Name of the address resource to return. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to return.
 *
 *  @return GTLRComputeQuery_AddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.addresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_AddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  Method: compute.addresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_AddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves an aggregated list of autoscalers.
 *
 *  Method: compute.autoscalers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AutoscalerAggregatedList.
 *
 *  Retrieves an aggregated list of autoscalers.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified autoscaler.
 *
 *  Method: compute.autoscalers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersDeleteWithproject:zoneProperty:autoscaler:]

/** Name of the autoscaler to delete. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to delete.
 *
 *  @return GTLRComputeQuery_AutoscalersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Returns the specified autoscaler resource. Gets a list of available
 *  autoscalers by making a list() request.
 *
 *  Method: compute.autoscalers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersGetWithproject:zoneProperty:autoscaler:]

/** Name of the autoscaler to return. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Autoscaler.
 *
 *  Returns the specified autoscaler resource. Gets a list of available
 *  autoscalers by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to return.
 *
 *  @return GTLRComputeQuery_AutoscalersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  Method: compute.autoscalers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AutoscalerList.
 *
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.autoscalers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersPatchWithObject:project:zoneProperty:]

/** Name of the autoscaler to patch. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersUpdateWithObject:project:zoneProperty:]

/** Name of the autoscaler to update. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Adds a key for validating requests with signed URLs for this backend bucket.
 *
 *  Method: compute.backendBuckets.addSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsAddSignedUrlKey : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsAddSignedUrlKeyWithObject:project:backendBucket:]

/**
 *  Name of the BackendBucket resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a key for validating requests with signed URLs for this backend bucket.
 *
 *  @param object The @c GTLRCompute_SignedUrlKey to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to which the Signed
 *    URL Key should be added. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendBucketsAddSignedUrlKey
 */
+ (instancetype)queryWithObject:(GTLRCompute_SignedUrlKey *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Deletes the specified BackendBucket resource.
 *
 *  Method: compute.backendBuckets.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsDeleteWithproject:backendBucket:]

/** Name of the BackendBucket resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified BackendBucket resource.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to delete.
 *
 *  @return GTLRComputeQuery_BackendBucketsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket;

@end

/**
 *  Deletes a key for validating requests with signed URLs for this backend
 *  bucket.
 *
 *  Method: compute.backendBuckets.deleteSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsDeleteSignedUrlKey : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsDeleteSignedUrlKeyWithproject:backendBucket:keyName:]

/**
 *  Name of the BackendBucket resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** The name of the Signed URL Key to delete. */
@property(nonatomic, copy, nullable) NSString *keyName;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a key for validating requests with signed URLs for this backend
 *  bucket.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to which the Signed
 *    URL Key should be added. The name should conform to RFC1035.
 *  @param keyName The name of the Signed URL Key to delete.
 *
 *  @return GTLRComputeQuery_BackendBucketsDeleteSignedUrlKey
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket
                         keyName:(NSString *)keyName;

@end

/**
 *  Returns the specified BackendBucket resource. Gets a list of available
 *  backend buckets by making a list() request.
 *
 *  Method: compute.backendBuckets.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsGetWithproject:backendBucket:]

/** Name of the BackendBucket resource to return. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendBucket.
 *
 *  Returns the specified BackendBucket resource. Gets a list of available
 *  backend buckets by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to return.
 *
 *  @return GTLRComputeQuery_BackendBucketsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket;

@end

/**
 *  Creates a BackendBucket resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.backendBuckets.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a BackendBucket resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendBucketsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of BackendBucket resources available to the specified
 *  project.
 *
 *  Method: compute.backendBuckets.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendBucketList.
 *
 *  Retrieves the list of BackendBucket resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendBucketsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified BackendBucket resource with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.backendBuckets.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsPatchWithObject:project:backendBucket:]

/** Name of the BackendBucket resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendBucket resource with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to patch.
 *
 *  @return GTLRComputeQuery_BackendBucketsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Updates the specified BackendBucket resource with the data included in the
 *  request.
 *
 *  Method: compute.backendBuckets.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendBucketsUpdateWithObject:project:backendBucket:]

/** Name of the BackendBucket resource to update. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendBucket resource with the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to update.
 *
 *  @return GTLRComputeQuery_BackendBucketsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Adds a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  Method: compute.backendServices.addSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesAddSignedUrlKey : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesAddSignedUrlKeyWithObject:project:backendService:]

/**
 *  Name of the BackendService resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  @param object The @c GTLRCompute_SignedUrlKey to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to which the
 *    Signed URL Key should be added. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendServicesAddSignedUrlKey
 */
+ (instancetype)queryWithObject:(GTLRCompute_SignedUrlKey *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves the list of all BackendService resources, regional and global,
 *  available to the specified project.
 *
 *  Method: compute.backendServices.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceAggregatedList.
 *
 *  Retrieves the list of all BackendService resources, regional and global,
 *  available to the specified project.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_BackendServicesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified BackendService resource.
 *
 *  Method: compute.backendServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesDeleteWithproject:backendService:]

/** Name of the BackendService resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to delete.
 *
 *  @return GTLRComputeQuery_BackendServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Deletes a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  Method: compute.backendServices.deleteSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesDeleteSignedUrlKey : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesDeleteSignedUrlKeyWithproject:backendService:keyName:]

/**
 *  Name of the BackendService resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** The name of the Signed URL Key to delete. */
@property(nonatomic, copy, nullable) NSString *keyName;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to which the
 *    Signed URL Key should be added. The name should conform to RFC1035.
 *  @param keyName The name of the Signed URL Key to delete.
 *
 *  @return GTLRComputeQuery_BackendServicesDeleteSignedUrlKey
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService
                         keyName:(NSString *)keyName;

@end

/**
 *  Returns the specified BackendService resource. Gets a list of available
 *  backend services.
 *
 *  Method: compute.backendServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesGetWithproject:backendService:]

/** Name of the BackendService resource to return. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendService.
 *
 *  Returns the specified BackendService resource. Gets a list of available
 *  backend services.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to return.
 *
 *  @return GTLRComputeQuery_BackendServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Gets the most recent health check results for this BackendService.
 *
 *  Method: compute.backendServices.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesGetHealthWithObject:project:backendService:]

/**
 *  Name of the BackendService resource to which the queried instance belongs.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceGroupHealth.
 *
 *  Gets the most recent health check results for this BackendService.
 *
 *  @param object The @c GTLRCompute_ResourceGroupReference to include in the
 *    query.
 *  @param project NSString
 *  @param backendService Name of the BackendService resource to which the
 *    queried instance belongs.
 *
 *  @return GTLRComputeQuery_BackendServicesGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourceGroupReference *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when creating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  Method: compute.backendServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when creating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  Method: compute.backendServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceList.
 *
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.backendServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesPatchWithObject:project:backendService:]

/** Name of the BackendService resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to patch.
 *
 *  @return GTLRComputeQuery_BackendServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Sets the security policy for the specified backend service.
 *
 *  Method: compute.backendServices.setSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesSetSecurityPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesSetSecurityPolicyWithObject:project:backendService:]

/**
 *  Name of the BackendService resource to which the security policy should be
 *  set. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the security policy for the specified backend service.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyReference to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to which the
 *    security policy should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendServicesSetSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyReference *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Updates the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information.
 *
 *  Method: compute.backendServices.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesUpdateWithObject:project:backendService:]

/** Name of the BackendService resource to update. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendService resource with the data included in the
 *  request. There are several restrictions and guidelines to keep in mind when
 *  updating a backend service. Read Restrictions and Guidelines for more
 *  information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @return GTLRComputeQuery_BackendServicesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves an aggregated list of persistent disks.
 *
 *  Method: compute.disks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_DiskAggregatedList.
 *
 *  Retrieves an aggregated list of persistent disks.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_DisksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Creates a snapshot of a specified persistent disk.
 *
 *  Method: compute.disks.createSnapshot
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksCreateSnapshot : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksCreateSnapshotWithObject:project:zoneProperty:disk:]

/** Name of the persistent disk to snapshot. */
@property(nonatomic, copy, nullable) NSString *disk;

@property(nonatomic, assign) BOOL guestFlush;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a snapshot of a specified persistent disk.
 *
 *  @param object The @c GTLRCompute_Snapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to snapshot.
 *
 *  @return GTLRComputeQuery_DisksCreateSnapshot
 */
+ (instancetype)queryWithObject:(GTLRCompute_Snapshot *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  Method: compute.disks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksDeleteWithproject:zoneProperty:disk:]

/** Name of the persistent disk to delete. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to delete.
 *
 *  @return GTLRComputeQuery_DisksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Returns a specified persistent disk. Gets a list of available persistent
 *  disks by making a list() request.
 *
 *  Method: compute.disks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksGetWithproject:zoneProperty:disk:]

/** Name of the persistent disk to return. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Disk.
 *
 *  Returns a specified persistent disk. Gets a list of available persistent
 *  disks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to return.
 *
 *  @return GTLRComputeQuery_DisksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.disks.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksGetIamPolicyWithproject:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk with a sourceImage, a sourceSnapshot, or
 *  create an empty 500 GB data disk by omitting all properties. You can also
 *  create a disk that is larger than the default size by specifying the sizeGb
 *  property.
 *
 *  Method: compute.disks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Optional. Source image to restore onto a disk. */
@property(nonatomic, copy, nullable) NSString *sourceImage;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk with a sourceImage, a sourceSnapshot, or
 *  create an empty 500 GB data disk by omitting all properties. You can also
 *  create a disk that is larger than the default size by specifying the sizeGb
 *  property.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_DisksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  Method: compute.disks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskList.
 *
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_DisksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Resizes the specified persistent disk. You can only increase the size of the
 *  disk.
 *
 *  Method: compute.disks.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksResizeWithObject:project:zoneProperty:disk:]

/** The name of the persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the specified persistent disk. You can only increase the size of the
 *  disk.
 *
 *  @param object The @c GTLRCompute_DisksResizeRequest to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @return GTLRComputeQuery_DisksResize
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksResizeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.disks.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksSetIamPolicyWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on a disk. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.disks.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksSetLabelsWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a disk. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_ZoneSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetLabelsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.disks.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksTestIamPermissionsWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of disk types.
 *
 *  Method: compute.diskTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_DiskTypeAggregatedList.
 *
 *  Retrieves an aggregated list of disk types.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_DiskTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified disk type. Gets a list of available disk types by
 *  making a list() request.
 *
 *  Method: compute.diskTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesGetWithproject:zoneProperty:diskType:]

/** Name of the disk type to return. */
@property(nonatomic, copy, nullable) NSString *diskType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskType.
 *
 *  Returns the specified disk type. Gets a list of available disk types by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param diskType Name of the disk type to return.
 *
 *  @return GTLRComputeQuery_DiskTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        diskType:(NSString *)diskType;

@end

/**
 *  Retrieves a list of disk types available to the specified project.
 *
 *  Method: compute.diskTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskTypeList.
 *
 *  Retrieves a list of disk types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_DiskTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified firewall.
 *
 *  Method: compute.firewalls.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsDeleteWithproject:firewall:]

/** Name of the firewall rule to delete. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to delete.
 *
 *  @return GTLRComputeQuery_FirewallsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Returns the specified firewall.
 *
 *  Method: compute.firewalls.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsGetWithproject:firewall:]

/** Name of the firewall rule to return. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Firewall.
 *
 *  Returns the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to return.
 *
 *  @return GTLRComputeQuery_FirewallsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.firewalls.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_FirewallsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  Method: compute.firewalls.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_FirewallList.
 *
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_FirewallsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.firewalls.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsPatchWithObject:project:firewall:]

/** Name of the firewall rule to patch. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to patch.
 *
 *  @return GTLRComputeQuery_FirewallsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *  The PUT method can only update the following fields of firewall rule:
 *  allowed, description, sourceRanges, sourceTags, targetTags.
 *
 *  Method: compute.firewalls.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsUpdateWithObject:project:firewall:]

/** Name of the firewall rule to update. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *  The PUT method can only update the following fields of firewall rule:
 *  allowed, description, sourceRanges, sourceTags, targetTags.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to update.
 *
 *  @return GTLRComputeQuery_FirewallsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Retrieves an aggregated list of forwarding rules.
 *
 *  Method: compute.forwardingRules.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleAggregatedList.
 *
 *  Retrieves an aggregated list of forwarding rules.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ForwardingRulesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesDeleteWithproject:region:forwardingRule:]

/** Name of the ForwardingRule resource to delete. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @return GTLRComputeQuery_ForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesGetWithproject:region:forwardingRule:]

/** Name of the ForwardingRule resource to return. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @return GTLRComputeQuery_ForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.forwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_ForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  Method: compute.forwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_ForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  Method: compute.forwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesSetTarget : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesSetTargetWithObject:project:region:forwardingRule:]

/** Name of the ForwardingRule resource in which target is to be set. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @return GTLRComputeQuery_ForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.globalAddresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesDeleteWithproject:address:]

/** Name of the address resource to delete. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @return GTLRComputeQuery_GlobalAddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource. Gets a list of available addresses
 *  by making a list() request.
 *
 *  Method: compute.globalAddresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesGetWithproject:address:]

/** Name of the address resource to return. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource. Gets a list of available addresses
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to return.
 *
 *  @return GTLRComputeQuery_GlobalAddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.globalAddresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalAddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of global addresses.
 *
 *  Method: compute.globalAddresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of global addresses.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalAddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified GlobalForwardingRule resource.
 *
 *  Method: compute.globalForwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesDeleteWithproject:forwardingRule:]

/** Name of the ForwardingRule resource to delete. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified GlobalForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified GlobalForwardingRule resource. Gets a list of
 *  available forwarding rules by making a list() request.
 *
 *  Method: compute.globalForwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesGetWithproject:forwardingRule:]

/** Name of the ForwardingRule resource to return. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified GlobalForwardingRule resource. Gets a list of
 *  available forwarding rules by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a GlobalForwardingRule resource in the specified project using the
 *  data included in the request.
 *
 *  Method: compute.globalForwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a GlobalForwardingRule resource in the specified project using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of GlobalForwardingRule resources available to the
 *  specified project.
 *
 *  Method: compute.globalForwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of GlobalForwardingRule resources available to the
 *  specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes target URL for the GlobalForwardingRule resource. The new target
 *  should be of the same type as the old target.
 *
 *  Method: compute.globalForwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesSetTarget : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesSetTargetWithObject:project:forwardingRule:]

/** Name of the ForwardingRule resource in which target is to be set. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for the GlobalForwardingRule resource. The new target
 *  should be of the same type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Retrieves an aggregated list of all operations.
 *
 *  Method: compute.globalOperations.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_OperationAggregatedList.
 *
 *  Retrieves an aggregated list of all operations.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalOperationsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Operations resource.
 *
 *  Method: compute.globalOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsDeleteWithproject:operation:]

/** Name of the Operations resource to delete. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @return GTLRComputeQuery_GlobalOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified Operations resource. Gets a list of operations by
 *  making a list() request.
 *
 *  Method: compute.globalOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsGetWithproject:operation:]

/** Name of the Operations resource to return. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified Operations resource. Gets a list of operations by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @return GTLRComputeQuery_GlobalOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  Method: compute.globalOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified HealthCheck resource.
 *
 *  Method: compute.healthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksDeleteWithproject:healthCheck:]

/** Name of the HealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to delete.
 *
 *  @return GTLRComputeQuery_HealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Returns the specified HealthCheck resource. Gets a list of available health
 *  checks by making a list() request.
 *
 *  Method: compute.healthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksGetWithproject:healthCheck:]

/** Name of the HealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HealthCheck.
 *
 *  Returns the specified HealthCheck resource. Gets a list of available health
 *  checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to return.
 *
 *  @return GTLRComputeQuery_HealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.healthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.healthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HealthCheckList.
 *
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.healthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksPatchWithObject:project:healthCheck:]

/** Name of the HealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to patch.
 *
 *  @return GTLRComputeQuery_HealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.healthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHealthChecksUpdateWithObject:project:healthCheck:]

/** Name of the HealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to update.
 *
 *  @return GTLRComputeQuery_HealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  Method: compute.httpHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksDeleteWithproject:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to delete.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Returns the specified HttpHealthCheck resource. Gets a list of available
 *  HTTP health checks by making a list() request.
 *
 *  Method: compute.httpHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksGetWithproject:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheck.
 *
 *  Returns the specified HttpHealthCheck resource. Gets a list of available
 *  HTTP health checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to return.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheckList.
 *
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.httpHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksPatchWithObject:project:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to patch.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksUpdateWithObject:project:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to update.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  Method: compute.httpsHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksDeleteWithproject:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to delete.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Returns the specified HttpsHealthCheck resource. Gets a list of available
 *  HTTPS health checks by making a list() request.
 *
 *  Method: compute.httpsHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksGetWithproject:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheck.
 *
 *  Returns the specified HttpsHealthCheck resource. Gets a list of available
 *  HTTPS health checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to return.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpsHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheckList.
 *
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.httpsHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksPatchWithObject:project:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to patch.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksUpdateWithObject:project:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to update.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Deletes the specified image.
 *
 *  Method: compute.images.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesDeleteWithproject:image:]

/** Name of the image resource to delete. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified image.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to delete.
 *
 *  @return GTLRComputeQuery_ImagesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Sets the deprecation status of an image.
 *  If an empty request body is given, clears the deprecation status instead.
 *
 *  Method: compute.images.deprecate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDeprecate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesDeprecateWithObject:project:image:]

/** Image name. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the deprecation status of an image.
 *  If an empty request body is given, clears the deprecation status instead.
 *
 *  @param object The @c GTLRCompute_DeprecationStatus to include in the query.
 *  @param project Project ID for this request.
 *  @param image Image name.
 *
 *  @return GTLRComputeQuery_ImagesDeprecate
 */
+ (instancetype)queryWithObject:(GTLRCompute_DeprecationStatus *)object
                        project:(NSString *)project
                          image:(NSString *)image;

@end

/**
 *  Returns the specified image. Gets a list of available images by making a
 *  list() request.
 *
 *  Method: compute.images.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesGetWithproject:image:]

/** Name of the image resource to return. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the specified image. Gets a list of available images by making a
 *  list() request.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to return.
 *
 *  @return GTLRComputeQuery_ImagesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Returns the latest image that is part of an image family and is not
 *  deprecated.
 *
 *  Method: compute.images.getFromFamily
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGetFromFamily : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesGetFromFamilyWithproject:family:]

/** Name of the image family to search for. */
@property(nonatomic, copy, nullable) NSString *family;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the latest image that is part of an image family and is not
 *  deprecated.
 *
 *  @param project Project ID for this request.
 *  @param family Name of the image family to search for.
 *
 *  @return GTLRComputeQuery_ImagesGetFromFamily
 */
+ (instancetype)queryWithProject:(NSString *)project
                          family:(NSString *)family;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.images.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesGetIamPolicyWithproject:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.images.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ImagesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesInsertWithObject:project:]

/** Force image creation if true. */
@property(nonatomic, assign) BOOL forceCreate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Image to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ImagesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Image *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of custom images available to the specified project.
 *  Custom images are images you create that belong to your project. This method
 *  does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 8. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *
 *  Method: compute.images.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ImageList.
 *
 *  Retrieves the list of custom images available to the specified project.
 *  Custom images are images you create that belong to your project. This method
 *  does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 8. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ImagesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.images.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesSetIamPolicyWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on an image. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.images.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesSetLabelsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on an image. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.images.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesTestIamPermissionsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Flags the specified instances to be removed from the managed instance group.
 *  Abandoning an instance does not delete the instance, but it does remove the
 *  instance from any target pools that are applied by the managed instance
 *  group. This method reduces the targetSize of the managed instance group by
 *  the number of instances that you abandon. This operation is marked as DONE
 *  when the action is scheduled even if the instances have not yet been removed
 *  from the group. You must separately verify the status of the abandoning
 *  action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.abandonInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersAbandonInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersAbandonInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances to be removed from the managed instance group.
 *  Abandoning an instance does not delete the instance, but it does remove the
 *  instance from any target pools that are applied by the managed instance
 *  group. This method reduces the targetSize of the managed instance group by
 *  the number of instances that you abandon. This operation is marked as DONE
 *  when the action is scheduled even if the instances have not yet been removed
 *  from the group. You must separately verify the status of the abandoning
 *  action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersAbandonInstancesRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersAbandonInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersAbandonInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Retrieves the list of managed instance groups and groups them by zone.
 *
 *  Method: compute.instanceGroupManagers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerAggregatedList.
 *
 *  Retrieves the list of managed instance groups and groups them by zone.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroupManagers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersDeleteWithproject:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group to
 *    delete.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group for immediate
 *  deletion. The instances are also removed from any target pools of which they
 *  were a member. This method reduces the targetSize of the managed instance
 *  group by the number of instances that you delete. This operation is marked
 *  as DONE when the action is scheduled even if the instances are still being
 *  deleted. You must separately verify the status of the deleting action with
 *  the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.deleteInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDeleteInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersDeleteInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group for immediate
 *  deletion. The instances are also removed from any target pools of which they
 *  were a member. This method reduces the targetSize of the managed instance
 *  group by the number of instances that you delete. This operation is marked
 *  as DONE when the action is scheduled even if the instances are still being
 *  deleted. You must separately verify the status of the deleting action with
 *  the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersDeleteInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersDeleteInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersDeleteInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns all of the details about the specified managed instance group. Gets
 *  a list of available managed instance groups by making a list() request.
 *
 *  Method: compute.instanceGroupManagers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersGetWithproject:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManager.
 *
 *  Returns all of the details about the specified managed instance group. Gets
 *  a list of available managed instance groups by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method.
 *  A managed instance group can have up to 1000 VM instances per group. Please
 *  contact Cloud Support if you need an increase in this limit.
 *
 *  Method: compute.instanceGroupManagers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the managed instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method.
 *  A managed instance group can have up to 1000 VM instances per group. Please
 *  contact Cloud Support if you need an increase in this limit.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  Method: compute.instanceGroupManagers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerList.
 *
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action.
 *
 *  Method: compute.instanceGroupManagers.listManagedInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersListManagedInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersListManagedInstancesWithproject:zoneProperty:instanceGroupManager:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagersListManagedInstancesResponse.
 *
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersListManagedInstances
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listManagedInstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules.
 *
 *  Method: compute.instanceGroupManagers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersPatchWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the instance group manager. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the managed instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listManagedInstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    managed instance group.
 *  @param instanceGroupManager The name of the instance group manager.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately recreated. The instances are deleted and recreated using the
 *  current instance template for the managed instance group. This operation is
 *  marked as DONE when the flag is set even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.recreateInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersRecreateInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersRecreateInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately recreated. The instances are deleted and recreated using the
 *  current instance template for the managed instance group. This operation is
 *  marked as DONE when the flag is set even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersRecreateInstancesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersRecreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersRecreateInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *  When resizing down, the instance group arbitrarily chooses the order in
 *  which VMs are deleted. The group takes into account some VM attributes when
 *  making the selection including:
 *  + The status of the VM instance. + The health of the VM instance. + The
 *  instance template version the VM is based on. + For regional managed
 *  instance groups, the location of the VM instance.
 *  This list is subject to change.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  Method: compute.instanceGroupManagers.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersResizeWithproject:zoneProperty:instanceGroupManager:size:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The number of running instances that the managed instance group should
 *  maintain at any given time. The group automatically adds or removes
 *  instances to maintain the number of instances specified by this parameter.
 */
@property(nonatomic, assign) NSInteger size;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *  When resizing down, the instance group arbitrarily chooses the order in
 *  which VMs are deleted. The group takes into account some VM attributes when
 *  making the selection including:
 *  + The status of the VM instance. + The health of the VM instance. + The
 *  instance template version the VM is based on. + For regional managed
 *  instance groups, the location of the VM instance.
 *  This list is subject to change.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *  @param size The number of running instances that the managed instance group
 *    should maintain at any given time. The group automatically adds or removes
 *    instances to maintain the number of instances specified by this parameter.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersResize
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager
                            size:(NSInteger)size;

@end

/**
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you recreate them.
 *
 *  Method: compute.instanceGroupManagers.setInstanceTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersSetInstanceTemplateWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you recreate them.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  Method: compute.instanceGroupManagers.setTargetPools
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetTargetPools : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersSetTargetPoolsWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersSetTargetPools
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  Method: compute.instanceGroups.addInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsAddInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsAddInstancesWithObject:project:zoneProperty:instanceGroup:]

/** The name of the instance group where you are adding instances. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsAddInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where you are adding
 *    instances.
 *
 *  @return GTLRComputeQuery_InstanceGroupsAddInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsAddInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Retrieves the list of instance groups and sorts them by zone.
 *
 *  Method: compute.instanceGroups.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupAggregatedList.
 *
 *  Retrieves the list of instance groups and sorts them by zone.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceGroupsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsDeleteWithproject:zoneProperty:instanceGroup:]

/** The name of the instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group to delete.
 *
 *  @return GTLRComputeQuery_InstanceGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Returns the specified instance group. Gets a list of available instance
 *  groups by making a list() request.
 *
 *  Method: compute.instanceGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsGetWithproject:zoneProperty:instanceGroup:]

/** The name of the instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroup.
 *
 *  Returns the specified instance group. Gets a list of available instance
 *  groups by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  Method: compute.instanceGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  @param object The @c GTLRCompute_InstanceGroup to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of instance groups that are located in the specified
 *  project and zone.
 *
 *  Method: compute.instanceGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupList.
 *
 *  Retrieves the list of instance groups that are located in the specified
 *  project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *
 *  @return GTLRComputeQuery_InstanceGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists the instances in the specified instance group.
 *
 *  Method: compute.instanceGroups.listInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsListInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsListInstancesWithObject:project:zoneProperty:instanceGroup:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The name of the instance group from which you want to generate a list of
 *  included instances.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupsListInstances.
 *
 *  Lists the instances in the specified instance group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsListInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group from which you want to
 *    generate a list of included instances.
 *
 *  @return GTLRComputeQuery_InstanceGroupsListInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsListInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration before the VM instance is removed or deleted.
 *
 *  Method: compute.instanceGroups.removeInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsRemoveInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsRemoveInstancesWithObject:project:zoneProperty:instanceGroup:]

/**
 *  The name of the instance group where the specified instances will be
 *  removed.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration before the VM instance is removed or deleted.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsRemoveInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the specified
 *    instances will be removed.
 *
 *  @return GTLRComputeQuery_InstanceGroupsRemoveInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsRemoveInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Sets the named ports for the specified instance group.
 *
 *  Method: compute.instanceGroups.setNamedPorts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsSetNamedPorts : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsSetNamedPortsWithObject:project:zoneProperty:instanceGroup:]

/** The name of the instance group where the named ports are updated. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the named ports for the specified instance group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsSetNamedPortsRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the named ports
 *    are updated.
 *
 *  @return GTLRComputeQuery_InstanceGroupsSetNamedPorts
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsSetNamedPortsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Adds an access config to an instance's network interface.
 *
 *  Method: compute.instances.addAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAddAccessConfig : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAddAccessConfigWithObject:project:zoneProperty:instance:networkInterface:]

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface to add to this instance. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an access config to an instance's network interface.
 *
 *  @param object The @c GTLRCompute_AccessConfig to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface to add to this
 *    instance.
 *
 *  @return GTLRComputeQuery_InstancesAddAccessConfig
 */
+ (instancetype)queryWithObject:(GTLRCompute_AccessConfig *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Retrieves aggregated list of all of the instances in your project across all
 *  regions and zones.
 *
 *  Method: compute.instances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceAggregatedList.
 *
 *  Retrieves aggregated list of all of the instances in your project across all
 *  regions and zones.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Attaches an existing Disk resource to an instance. You must first create the
 *  disk before you can attach it. It is not possible to create and attach a
 *  disk at the same time. For more information, read Adding a persistent disk
 *  to your instance.
 *
 *  Method: compute.instances.attachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAttachDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAttachDiskWithObject:project:zoneProperty:instance:]

/**
 *  Whether to force attach the disk even if it's currently attached to another
 *  instance. This is only available for regional disks.
 */
@property(nonatomic, assign) BOOL forceAttach;

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Attaches an existing Disk resource to an instance. You must first create the
 *  disk before you can attach it. It is not possible to create and attach a
 *  disk at the same time. For more information, read Adding a persistent disk
 *  to your instance.
 *
 *  @param object The @c GTLRCompute_AttachedDisk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *
 *  @return GTLRComputeQuery_InstancesAttachDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_AttachedDisk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Deletes the specified Instance resource. For more information, see Stopping
 *  or Deleting an Instance.
 *
 *  Method: compute.instances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDeleteWithproject:zoneProperty:instance:]

/** Name of the instance resource to delete. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Instance resource. For more information, see Stopping
 *  or Deleting an Instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to delete.
 *
 *  @return GTLRComputeQuery_InstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Deletes an access config from an instance's network interface.
 *
 *  Method: compute.instances.deleteAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDeleteAccessConfig : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDeleteAccessConfigWithproject:zoneProperty:instance:accessConfig:networkInterface:]

/** The name of the access config to delete. */
@property(nonatomic, copy, nullable) NSString *accessConfig;

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes an access config from an instance's network interface.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param accessConfig The name of the access config to delete.
 *  @param networkInterface The name of the network interface.
 *
 *  @return GTLRComputeQuery_InstancesDeleteAccessConfig
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                    accessConfig:(NSString *)accessConfig
                networkInterface:(NSString *)networkInterface;

@end

/**
 *  Detaches a disk from an instance.
 *
 *  Method: compute.instances.detachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDetachDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDetachDiskWithproject:zoneProperty:instance:deviceName:]

/**
 *  The device name of the disk to detach. Make a get() request on the instance
 *  to view currently attached disks and device names.
 */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** Instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Detaches a disk from an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name for this request.
 *  @param deviceName The device name of the disk to detach. Make a get()
 *    request on the instance to view currently attached disks and device names.
 *
 *  @return GTLRComputeQuery_InstancesDetachDisk
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Returns the specified Instance resource. Gets a list of available instances
 *  by making a list() request.
 *
 *  Method: compute.instances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesGetWithproject:zoneProperty:instance:]

/** Name of the instance resource to return. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Instance.
 *
 *  Returns the specified Instance resource. Gets a list of available instances
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to return.
 *
 *  @return GTLRComputeQuery_InstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.instances.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesGetIamPolicyWithproject:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Returns the last 1 MB of serial port output from the specified instance.
 *
 *  Method: compute.instances.getSerialPortOutput
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetSerialPortOutput : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesGetSerialPortOutputWithproject:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  Specifies which COM or serial port to retrieve data from.
 *
 *  @note If not set, the documented server-side default will be 1 (from the
 *        range 1..4).
 */
@property(nonatomic, assign) NSInteger port;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Returns output starting from a specific byte position. Use this to page
 *  through output when the output is too large to return in a single request.
 *  For the initial request, leave this field unspecified. For subsequent calls,
 *  this field should be set to the next value returned in the previous call.
 */
@property(nonatomic, assign) long long start;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_SerialPortOutput.
 *
 *  Returns the last 1 MB of serial port output from the specified instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesGetSerialPortOutput
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.instances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Specifies instance template to create the instance.
 *  This field is optional. It can be a full or partial URL. For example, the
 *  following are all valid URLs to an instance template:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/global/instanceTemplates/instanceTemplate
 *  - projects/project/global/instanceTemplates/instanceTemplate
 *  - global/instanceTemplates/instanceTemplate
 */
@property(nonatomic, copy, nullable) NSString *sourceInstanceTemplate;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Instance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Instance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  Method: compute.instances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceList.
 *
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of referrers to instances contained within the specified
 *  zone. For more information, read Viewing Referrers to VM Instances.
 *
 *  Method: compute.instances.listReferrers
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesListReferrers : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesListReferrersWithproject:zoneProperty:instance:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Name of the target instance scoping this request, or '-' if the request
 *  should span over all instances in the container.
 */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceListReferrers.
 *
 *  Retrieves the list of referrers to instances contained within the specified
 *  zone. For more information, read Viewing Referrers to VM Instances.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the target instance scoping this request, or '-' if
 *    the request should span over all instances in the container.
 *
 *  @return GTLRComputeQuery_InstancesListReferrers
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Performs a reset on the instance. This is a hard reset; the VM does not do a
 *  graceful shutdown. For more information, see Resetting an instance.
 *
 *  Method: compute.instances.reset
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesReset : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesResetWithproject:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Performs a reset on the instance. This is a hard reset; the VM does not do a
 *  graceful shutdown. For more information, see Resetting an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesReset
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Sets deletion protection on the instance.
 *
 *  Method: compute.instances.setDeletionProtection
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetDeletionProtection : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetDeletionProtectionWithproject:zoneProperty:resource:]

/**
 *  Whether the resource should be protected against deletion.
 *
 *  @note If not set, the documented server-side default will be true.
 */
@property(nonatomic, assign) BOOL deletionProtection;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets deletion protection on the instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesSetDeletionProtection
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  Method: compute.instances.setDiskAutoDelete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetDiskAutoDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetDiskAutoDeleteWithproject:zoneProperty:instance:autoDelete:deviceName:]

/** Whether to auto-delete the disk when the instance is deleted. */
@property(nonatomic, assign) BOOL autoDelete;

/**
 *  The device name of the disk to modify. Make a get() request on the instance
 *  to view currently attached disks and device names.
 */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param autoDelete Whether to auto-delete the disk when the instance is
 *    deleted.
 *  @param deviceName The device name of the disk to modify. Make a get()
 *    request on the instance to view currently attached disks and device names.
 *
 *  @return GTLRComputeQuery_InstancesSetDiskAutoDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      autoDelete:(BOOL)autoDelete
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.instances.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetIamPolicyWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Sets labels on an instance. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.instances.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetLabelsWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets labels on an instance. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_InstancesSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetLabelsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the number and/or type of accelerator for a stopped instance to the
 *  values specified in the request.
 *
 *  Method: compute.instances.setMachineResources
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMachineResources : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMachineResourcesWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the number and/or type of accelerator for a stopped instance to the
 *  values specified in the request.
 *
 *  @param object The @c GTLRCompute_InstancesSetMachineResourcesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMachineResources
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMachineResourcesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  Method: compute.instances.setMachineType
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMachineType : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMachineTypeWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  @param object The @c GTLRCompute_InstancesSetMachineTypeRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMachineType
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMachineTypeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  Method: compute.instances.setMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMetadata : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMetadataWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the minimum CPU platform that this instance should use. This method
 *  can only be called on a stopped instance. For more information, read
 *  Specifying a Minimum CPU Platform.
 *
 *  Method: compute.instances.setMinCpuPlatform
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMinCpuPlatform : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMinCpuPlatformWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the minimum CPU platform that this instance should use. This method
 *  can only be called on a stopped instance. For more information, read
 *  Specifying a Minimum CPU Platform.
 *
 *  @param object The @c GTLRCompute_InstancesSetMinCpuPlatformRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMinCpuPlatform
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMinCpuPlatformRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets an instance's scheduling options.
 *
 *  Method: compute.instances.setScheduling
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetScheduling : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetSchedulingWithObject:project:zoneProperty:instance:]

/** Instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets an instance's scheduling options.
 *
 *  @param object The @c GTLRCompute_Scheduling to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name for this request.
 *
 *  @return GTLRComputeQuery_InstancesSetScheduling
 */
+ (instancetype)queryWithObject:(GTLRCompute_Scheduling *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets the service account on the instance. For more information, read
 *  Changing the service account and access scopes for an instance.
 *
 *  Method: compute.instances.setServiceAccount
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetServiceAccount : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetServiceAccountWithObject:project:zoneProperty:instance:]

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the service account on the instance. For more information, read
 *  Changing the service account and access scopes for an instance.
 *
 *  @param object The @c GTLRCompute_InstancesSetServiceAccountRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @return GTLRComputeQuery_InstancesSetServiceAccount
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetServiceAccountRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets network tags for the specified instance to the data included in the
 *  request.
 *
 *  Method: compute.instances.setTags
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetTags : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetTagsWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets network tags for the specified instance to the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Tags to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetTags
 */
+ (instancetype)queryWithObject:(GTLRCompute_Tags *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Simulates a maintenance event on the instance.
 *
 *  Method: compute.instances.simulateMaintenanceEvent
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSimulateMaintenanceEvent : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSimulateMaintenanceEventWithproject:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Simulates a maintenance event on the instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSimulateMaintenanceEvent
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  Method: compute.instances.start
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStart : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStartWithproject:zoneProperty:instance:]

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @return GTLRComputeQuery_InstancesStart
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  Method: compute.instances.startWithEncryptionKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStartWithEncryptionKey : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStartWithEncryptionKeyWithObject:project:zoneProperty:instance:]

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  @param object The @c GTLRCompute_InstancesStartWithEncryptionKeyRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @return GTLRComputeQuery_InstancesStartWithEncryptionKey
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesStartWithEncryptionKeyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur VM
 *  usage charges while they are stopped. However, resources that the VM is
 *  using, such as persistent disks and static IP addresses, will continue to be
 *  charged until they are deleted. For more information, see Stopping an
 *  instance.
 *
 *  Method: compute.instances.stop
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStop : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStopWithproject:zoneProperty:instance:]

/** Name of the instance resource to stop. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur VM
 *  usage charges while they are stopped. However, resources that the VM is
 *  using, such as persistent disks and static IP addresses, will continue to be
 *  charged until they are deleted. For more information, see Stopping an
 *  instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to stop.
 *
 *  @return GTLRComputeQuery_InstancesStop
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.instances.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesTestIamPermissionsWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Updates the specified access config from an instance's network interface
 *  with the data included in the request. This method supports PATCH semantics
 *  and uses the JSON merge patch format and processing rules.
 *
 *  Method: compute.instances.updateAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesUpdateAccessConfig : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesUpdateAccessConfigWithObject:project:zoneProperty:instance:networkInterface:]

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface where the access config is attached. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified access config from an instance's network interface
 *  with the data included in the request. This method supports PATCH semantics
 *  and uses the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_AccessConfig to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface where the access
 *    config is attached.
 *
 *  @return GTLRComputeQuery_InstancesUpdateAccessConfig
 */
+ (instancetype)queryWithObject:(GTLRCompute_AccessConfig *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Updates an instance's network interface. This method follows PATCH
 *  semantics.
 *
 *  Method: compute.instances.updateNetworkInterface
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesUpdateNetworkInterface : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesUpdateNetworkInterfaceWithObject:project:zoneProperty:instance:networkInterface:]

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface to update. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an instance's network interface. This method follows PATCH
 *  semantics.
 *
 *  @param object The @c GTLRCompute_NetworkInterface to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface to update.
 *
 *  @return GTLRComputeQuery_InstancesUpdateNetworkInterface
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkInterface *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Deletes the specified instance template. Deleting an instance template is
 *  permanent and cannot be undone. It is not possible to delete templates that
 *  are already in use by a managed instance group.
 *
 *  Method: compute.instanceTemplates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesDeleteWithproject:instanceTemplate:]

/** The name of the instance template to delete. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance template. Deleting an instance template is
 *  permanent and cannot be undone. It is not possible to delete templates that
 *  are already in use by a managed instance group.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template to delete.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Returns the specified instance template. Gets a list of available instance
 *  templates by making a list() request.
 *
 *  Method: compute.instanceTemplates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesGetWithproject:instanceTemplate:]

/** The name of the instance template. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplate.
 *
 *  Returns the specified instance template. Gets a list of available instance
 *  templates by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.instanceTemplates.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesGetIamPolicyWithproject:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  Method: compute.instanceTemplates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  @param object The @c GTLRCompute_InstanceTemplate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceTemplate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of instance templates that are contained within the
 *  specified project.
 *
 *  Method: compute.instanceTemplates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplateList.
 *
 *  Retrieves a list of instance templates that are contained within the
 *  specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.instanceTemplates.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesSetIamPolicyWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.instanceTemplates.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesTestIamPermissionsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of interconnect attachments.
 *
 *  Method: compute.interconnectAttachments.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectAttachmentsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectAttachmentsAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectAttachmentAggregatedList.
 *
 *  Retrieves an aggregated list of interconnect attachments.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified interconnect attachment.
 *
 *  Method: compute.interconnectAttachments.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectAttachmentsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectAttachmentsDeleteWithproject:region:interconnectAttachment:]

/** Name of the interconnect attachment to delete. */
@property(nonatomic, copy, nullable) NSString *interconnectAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified interconnect attachment.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param interconnectAttachment Name of the interconnect attachment to delete.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
          interconnectAttachment:(NSString *)interconnectAttachment;

@end

/**
 *  Returns the specified interconnect attachment.
 *
 *  Method: compute.interconnectAttachments.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectAttachmentsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectAttachmentsGetWithproject:region:interconnectAttachment:]

/** Name of the interconnect attachment to return. */
@property(nonatomic, copy, nullable) NSString *interconnectAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InterconnectAttachment.
 *
 *  Returns the specified interconnect attachment.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param interconnectAttachment Name of the interconnect attachment to return.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
          interconnectAttachment:(NSString *)interconnectAttachment;

@end

/**
 *  Creates an InterconnectAttachment in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.interconnectAttachments.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectAttachmentsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectAttachmentsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an InterconnectAttachment in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_InterconnectAttachment to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InterconnectAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of interconnect attachments contained within the
 *  specified region.
 *
 *  Method: compute.interconnectAttachments.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectAttachmentsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectAttachmentsListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InterconnectAttachmentList.
 *
 *  Retrieves the list of interconnect attachments contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified interconnect attachment with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.interconnectAttachments.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectAttachmentsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectAttachmentsPatchWithObject:project:region:interconnectAttachment:]

/** Name of the interconnect attachment to patch. */
@property(nonatomic, copy, nullable) NSString *interconnectAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified interconnect attachment with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_InterconnectAttachment to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param interconnectAttachment Name of the interconnect attachment to patch.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_InterconnectAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region
         interconnectAttachment:(NSString *)interconnectAttachment;

@end

/**
 *  Returns the details for the specified interconnect location. Gets a list of
 *  available interconnect locations by making a list() request.
 *
 *  Method: compute.interconnectLocations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectLocationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectLocationsGetWithproject:interconnectLocation:]

/** Name of the interconnect location to return. */
@property(nonatomic, copy, nullable) NSString *interconnectLocation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectLocation.
 *
 *  Returns the details for the specified interconnect location. Gets a list of
 *  available interconnect locations by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param interconnectLocation Name of the interconnect location to return.
 *
 *  @return GTLRComputeQuery_InterconnectLocationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
            interconnectLocation:(NSString *)interconnectLocation;

@end

/**
 *  Retrieves the list of interconnect locations available to the specified
 *  project.
 *
 *  Method: compute.interconnectLocations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectLocationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectLocationsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectLocationList.
 *
 *  Retrieves the list of interconnect locations available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectLocationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified interconnect.
 *
 *  Method: compute.interconnects.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectsDeleteWithproject:interconnect:]

/** Name of the interconnect to delete. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified interconnect.
 *
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect to delete.
 *
 *  @return GTLRComputeQuery_InterconnectsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    interconnect:(NSString *)interconnect;

@end

/**
 *  Returns the specified interconnect. Get a list of available interconnects by
 *  making a list() request.
 *
 *  Method: compute.interconnects.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectsGetWithproject:interconnect:]

/** Name of the interconnect to return. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Interconnect.
 *
 *  Returns the specified interconnect. Get a list of available interconnects by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect to return.
 *
 *  @return GTLRComputeQuery_InterconnectsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    interconnect:(NSString *)interconnect;

@end

/**
 *  Returns the interconnectDiagnostics for the specified interconnect.
 *
 *  Method: compute.interconnects.getDiagnostics
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectsGetDiagnostics : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectsGetDiagnosticsWithproject:interconnect:]

/** Name of the interconnect resource to query. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectsGetDiagnosticsResponse.
 *
 *  Returns the interconnectDiagnostics for the specified interconnect.
 *
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect resource to query.
 *
 *  @return GTLRComputeQuery_InterconnectsGetDiagnostics
 */
+ (instancetype)queryWithProject:(NSString *)project
                    interconnect:(NSString *)interconnect;

@end

/**
 *  Creates a Interconnect in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.interconnects.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectsInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Interconnect in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Interconnect to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Interconnect *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of interconnect available to the specified project.
 *
 *  Method: compute.interconnects.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectList.
 *
 *  Retrieves the list of interconnect available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified interconnect with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.interconnects.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInterconnectsPatchWithObject:project:interconnect:]

/** Name of the interconnect to update. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified interconnect with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_Interconnect to include in the query.
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect to update.
 *
 *  @return GTLRComputeQuery_InterconnectsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Interconnect *)object
                        project:(NSString *)project
                   interconnect:(NSString *)interconnect;

@end

/**
 *  Return a specified license code. License codes are mirrored across all
 *  projects that have permissions to read the License Code.
 *
 *  Method: compute.licenseCodes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicenseCodesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicenseCodesGetWithproject:licenseCode:]

/** Number corresponding to the License code resource to return. */
@property(nonatomic, copy, nullable) NSString *licenseCode;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_LicenseCode.
 *
 *  Return a specified license code. License codes are mirrored across all
 *  projects that have permissions to read the License Code.
 *
 *  @param project Project ID for this request.
 *  @param licenseCode Number corresponding to the License code resource to
 *    return.
 *
 *  @return GTLRComputeQuery_LicenseCodesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                     licenseCode:(NSString *)licenseCode;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.licenseCodes.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicenseCodesTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicenseCodesTestIamPermissionsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicenseCodesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified license.
 *
 *  Method: compute.licenses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_LicensesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesDeleteWithproject:license:]

/** Name of the license resource to delete. */
@property(nonatomic, copy, nullable) NSString *license;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified license.
 *
 *  @param project Project ID for this request.
 *  @param license Name of the license resource to delete.
 *
 *  @return GTLRComputeQuery_LicensesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         license:(NSString *)license;

@end

/**
 *  Returns the specified License resource.
 *
 *  Method: compute.licenses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesGetWithproject:license:]

/** Name of the License resource to return. */
@property(nonatomic, copy, nullable) NSString *license;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_License.
 *
 *  Returns the specified License resource.
 *
 *  @param project Project ID for this request.
 *  @param license Name of the License resource to return.
 *
 *  @return GTLRComputeQuery_LicensesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         license:(NSString *)license;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.licenses.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesGetIamPolicyWithproject:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicensesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Create a License resource in the specified project.
 *
 *  Method: compute.licenses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_LicensesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Create a License resource in the specified project.
 *
 *  @param object The @c GTLRCompute_License to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_LicensesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_License *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of licenses available in the specified project. This
 *  method does not get any licenses that belong to other projects, including
 *  licenses attached to publicly-available images, like Debian 9. If you want
 *  to get a list of publicly-available licenses, use this method to make a
 *  request to the respective image project, such as debian-cloud or
 *  windows-cloud.
 *
 *  Method: compute.licenses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_LicensesListResponse.
 *
 *  Retrieves the list of licenses available in the specified project. This
 *  method does not get any licenses that belong to other projects, including
 *  licenses attached to publicly-available images, like Debian 9. If you want
 *  to get a list of publicly-available licenses, use this method to make a
 *  request to the respective image project, such as debian-cloud or
 *  windows-cloud.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_LicensesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.licenses.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_LicensesSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesSetIamPolicyWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicensesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.licenses.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesTestIamPermissionsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicensesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of machine types.
 *
 *  Method: compute.machineTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_MachineTypeAggregatedList.
 *
 *  Retrieves an aggregated list of machine types.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_MachineTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified machine type. Gets a list of available machine types
 *  by making a list() request.
 *
 *  Method: compute.machineTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesGetWithproject:zoneProperty:machineType:]

/** Name of the machine type to return. */
@property(nonatomic, copy, nullable) NSString *machineType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineType.
 *
 *  Returns the specified machine type. Gets a list of available machine types
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param machineType Name of the machine type to return.
 *
 *  @return GTLRComputeQuery_MachineTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     machineType:(NSString *)machineType;

@end

/**
 *  Retrieves a list of machine types available to the specified project.
 *
 *  Method: compute.machineTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineTypeList.
 *
 *  Retrieves a list of machine types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_MachineTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Adds a peering to the specified network.
 *
 *  Method: compute.networks.addPeering
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksAddPeering : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksAddPeeringWithObject:project:network:]

/** Name of the network resource to add peering to. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a peering to the specified network.
 *
 *  @param object The @c GTLRCompute_NetworksAddPeeringRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param network Name of the network resource to add peering to.
 *
 *  @return GTLRComputeQuery_NetworksAddPeering
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworksAddPeeringRequest *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Deletes the specified network.
 *
 *  Method: compute.networks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksDeleteWithproject:network:]

/** Name of the network to delete. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to delete.
 *
 *  @return GTLRComputeQuery_NetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Returns the specified network. Gets a list of available networks by making a
 *  list() request.
 *
 *  Method: compute.networks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksGetWithproject:network:]

/** Name of the network to return. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Network.
 *
 *  Returns the specified network. Gets a list of available networks by making a
 *  list() request.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to return.
 *
 *  @return GTLRComputeQuery_NetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.networks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Network to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Network *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of networks available to the specified project.
 *
 *  Method: compute.networks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NetworkList.
 *
 *  Retrieves the list of networks available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified network with the data included in the request. Only
 *  the following fields can be modified: routingConfig.routingMode.
 *
 *  Method: compute.networks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksPatchWithObject:project:network:]

/** Name of the network to update. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified network with the data included in the request. Only
 *  the following fields can be modified: routingConfig.routingMode.
 *
 *  @param object The @c GTLRCompute_Network to include in the query.
 *  @param project Project ID for this request.
 *  @param network Name of the network to update.
 *
 *  @return GTLRComputeQuery_NetworksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Network *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Removes a peering from the specified network.
 *
 *  Method: compute.networks.removePeering
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksRemovePeering : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksRemovePeeringWithObject:project:network:]

/** Name of the network resource to remove peering from. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes a peering from the specified network.
 *
 *  @param object The @c GTLRCompute_NetworksRemovePeeringRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param network Name of the network resource to remove peering from.
 *
 *  @return GTLRComputeQuery_NetworksRemovePeering
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworksRemovePeeringRequest *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Switches the network mode from auto subnet mode to custom subnet mode.
 *
 *  Method: compute.networks.switchToCustomMode
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksSwitchToCustomMode : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksSwitchToCustomModeWithproject:network:]

/** Name of the network to be updated. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Switches the network mode from auto subnet mode to custom subnet mode.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to be updated.
 *
 *  @return GTLRComputeQuery_NetworksSwitchToCustomMode
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Adds specified number of nodes to the node group.
 *
 *  Method: compute.nodeGroups.addNodes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsAddNodes : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsAddNodesWithObject:project:zoneProperty:nodeGroup:]

/** Name of the NodeGroup resource. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds specified number of nodes to the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsAddNodesRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource.
 *
 *  @return GTLRComputeQuery_NodeGroupsAddNodes
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsAddNodesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes
 *  for more details about each group.
 *
 *  Method: compute.nodeGroups.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NodeGroupAggregatedList.
 *
 *  Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes
 *  for more details about each group.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified NodeGroup resource.
 *
 *  Method: compute.nodeGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsDeleteWithproject:zoneProperty:nodeGroup:]

/** Name of the NodeGroup resource to delete. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified NodeGroup resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource to delete.
 *
 *  @return GTLRComputeQuery_NodeGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Deletes specified nodes from the node group.
 *
 *  Method: compute.nodeGroups.deleteNodes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsDeleteNodes : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsDeleteNodesWithObject:project:zoneProperty:nodeGroup:]

/** Name of the NodeGroup resource to delete. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes specified nodes from the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsDeleteNodesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource to delete.
 *
 *  @return GTLRComputeQuery_NodeGroupsDeleteNodes
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsDeleteNodesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Returns the specified NodeGroup. Get a list of available NodeGroups by
 *  making a list() request. Note: the "nodes" field should not be used. Use
 *  nodeGroups.listNodes instead.
 *
 *  Method: compute.nodeGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsGetWithproject:zoneProperty:nodeGroup:]

/** Name of the node group to return. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeGroup.
 *
 *  Returns the specified NodeGroup. Get a list of available NodeGroups by
 *  making a list() request. Note: the "nodes" field should not be used. Use
 *  nodeGroups.listNodes instead.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the node group to return.
 *
 *  @return GTLRComputeQuery_NodeGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.nodeGroups.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsGetIamPolicyWithproject:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Creates a NodeGroup resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.nodeGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsInsertWithObject:project:zoneProperty:initialNodeCount:]

/** Initial count of nodes in the node group. */
@property(nonatomic, assign) NSInteger initialNodeCount;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a NodeGroup resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_NodeGroup to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param initialNodeCount Initial count of nodes in the node group.
 *
 *  @return GTLRComputeQuery_NodeGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
               initialNodeCount:(NSInteger)initialNodeCount;

@end

/**
 *  Retrieves a list of node groups available to the specified project. Note:
 *  use nodeGroups.listNodes for more details about each group.
 *
 *  Method: compute.nodeGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeGroupList.
 *
 *  Retrieves a list of node groups available to the specified project. Note:
 *  use nodeGroups.listNodes for more details about each group.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists nodes in the node group.
 *
 *  Method: compute.nodeGroups.listNodes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsListNodes : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsListNodesWithproject:zoneProperty:nodeGroup:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/** Name of the NodeGroup resource whose nodes you want to list. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeGroupsListNodes.
 *
 *  Lists nodes in the node group.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource whose nodes you want to
 *    list.
 *
 *  @return GTLRComputeQuery_NodeGroupsListNodes
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.nodeGroups.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsSetIamPolicyWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Updates the node template of the node group.
 *
 *  Method: compute.nodeGroups.setNodeTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsSetNodeTemplate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsSetNodeTemplateWithObject:project:zoneProperty:nodeGroup:]

/** Name of the NodeGroup resource to update. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the node template of the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsSetNodeTemplateRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource to update.
 *
 *  @return GTLRComputeQuery_NodeGroupsSetNodeTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsSetNodeTemplateRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.nodeGroups.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeGroupsTestIamPermissionsWithObject:project:zoneProperty:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of node templates.
 *
 *  Method: compute.nodeTemplates.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NodeTemplateAggregatedList.
 *
 *  Retrieves an aggregated list of node templates.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified NodeTemplate resource.
 *
 *  Method: compute.nodeTemplates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeTemplatesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesDeleteWithproject:region:nodeTemplate:]

/** Name of the NodeTemplate resource to delete. */
@property(nonatomic, copy, nullable) NSString *nodeTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified NodeTemplate resource.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param nodeTemplate Name of the NodeTemplate resource to delete.
 *
 *  @return GTLRComputeQuery_NodeTemplatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                    nodeTemplate:(NSString *)nodeTemplate;

@end

/**
 *  Returns the specified node template. Gets a list of available node templates
 *  by making a list() request.
 *
 *  Method: compute.nodeTemplates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesGetWithproject:region:nodeTemplate:]

/** Name of the node template to return. */
@property(nonatomic, copy, nullable) NSString *nodeTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_NodeTemplate.
 *
 *  Returns the specified node template. Gets a list of available node templates
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param nodeTemplate Name of the node template to return.
 *
 *  @return GTLRComputeQuery_NodeTemplatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                    nodeTemplate:(NSString *)nodeTemplate;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.nodeTemplates.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesGetIamPolicyWithproject:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a NodeTemplate resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.nodeTemplates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeTemplatesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a NodeTemplate resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_NodeTemplate to include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeTemplate *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of node templates available to the specified project.
 *
 *  Method: compute.nodeTemplates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_NodeTemplateList.
 *
 *  Retrieves a list of node templates available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.nodeTemplates.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeTemplatesSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesSetIamPolicyWithObject:project:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.nodeTemplates.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTemplatesTestIamPermissionsWithObject:project:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of node types.
 *
 *  Method: compute.nodeTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTypesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NodeTypeAggregatedList.
 *
 *  Retrieves an aggregated list of node types.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NodeTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified node type. Gets a list of available node types by
 *  making a list() request.
 *
 *  Method: compute.nodeTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTypesGetWithproject:zoneProperty:nodeType:]

/** Name of the node type to return. */
@property(nonatomic, copy, nullable) NSString *nodeType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeType.
 *
 *  Returns the specified node type. Gets a list of available node types by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeType Name of the node type to return.
 *
 *  @return GTLRComputeQuery_NodeTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        nodeType:(NSString *)nodeType;

@end

/**
 *  Retrieves a list of node types available to the specified project.
 *
 *  Method: compute.nodeTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNodeTypesListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeTypeList.
 *
 *  Retrieves a list of node types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_NodeTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Disable this project as a shared VPC host project.
 *
 *  Method: compute.projects.disableXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsDisableXpnHost : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsDisableXpnHostWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Disable this project as a shared VPC host project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsDisableXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Disable a serivce resource (a.k.a service project) associated with this host
 *  project.
 *
 *  Method: compute.projects.disableXpnResource
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsDisableXpnResource : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsDisableXpnResourceWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Disable a serivce resource (a.k.a service project) associated with this host
 *  project.
 *
 *  @param object The @c GTLRCompute_ProjectsDisableXpnResourceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsDisableXpnResource
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsDisableXpnResourceRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Enable this project as a shared VPC host project.
 *
 *  Method: compute.projects.enableXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsEnableXpnHost : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsEnableXpnHostWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enable this project as a shared VPC host project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsEnableXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Enable service resource (a.k.a service project) for a host project, so that
 *  subnets in the host project can be used by instances in the service project.
 *
 *  Method: compute.projects.enableXpnResource
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsEnableXpnResource : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsEnableXpnResourceWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enable service resource (a.k.a service project) for a host project, so that
 *  subnets in the host project can be used by instances in the service project.
 *
 *  @param object The @c GTLRCompute_ProjectsEnableXpnResourceRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsEnableXpnResource
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsEnableXpnResourceRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Returns the specified Project resource.
 *
 *  Method: compute.projects.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ProjectsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsGetWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Project.
 *
 *  Returns the specified Project resource.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsGet
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Gets the shared VPC host project that this project links to. May be empty if
 *  no link exists.
 *
 *  Method: compute.projects.getXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsGetXpnHost : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsGetXpnHostWithproject:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Project.
 *
 *  Gets the shared VPC host project that this project links to. May be empty if
 *  no link exists.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsGetXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Gets service resources (a.k.a service project) associated with this host
 *  project.
 *
 *  Method: compute.projects.getXpnResources
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsGetXpnResources : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsGetXpnResourcesWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ProjectsGetXpnResources.
 *
 *  Gets service resources (a.k.a service project) associated with this host
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsGetXpnResources
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Lists all shared VPC host projects visible to the user in an organization.
 *
 *  Method: compute.projects.listXpnHosts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsListXpnHosts : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsListXpnHostsWithObject:project:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_XpnHostList.
 *
 *  Lists all shared VPC host projects visible to the user in an organization.
 *
 *  @param object The @c GTLRCompute_ProjectsListXpnHostsRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsListXpnHosts
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsListXpnHostsRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Moves a persistent disk from one zone to another.
 *
 *  Method: compute.projects.moveDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsMoveDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsMoveDiskWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves a persistent disk from one zone to another.
 *
 *  @param object The @c GTLRCompute_DiskMoveRequest to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsMoveDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_DiskMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Moves an instance and its attached persistent disks from one zone to
 *  another.
 *
 *  Method: compute.projects.moveInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsMoveInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsMoveInstanceWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves an instance and its attached persistent disks from one zone to
 *  another.
 *
 *  @param object The @c GTLRCompute_InstanceMoveRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsMoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  Method: compute.projects.setCommonInstanceMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsSetCommonInstanceMetadata : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsSetCommonInstanceMetadataWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsSetCommonInstanceMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project;

@end

/**
 *  Sets the default network tier of the project. The default network tier is
 *  used when an address/forwardingRule/instance is created without specifying
 *  the network tier field.
 *
 *  Method: compute.projects.setDefaultNetworkTier
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsSetDefaultNetworkTier : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsSetDefaultNetworkTierWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the default network tier of the project. The default network tier is
 *  used when an address/forwardingRule/instance is created without specifying
 *  the network tier field.
 *
 *  @param object The @c GTLRCompute_ProjectsSetDefaultNetworkTierRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsSetDefaultNetworkTier
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsSetDefaultNetworkTierRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  Method: compute.projects.setUsageExportBucket
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ProjectsSetUsageExportBucket : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsSetUsageExportBucketWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  @param object The @c GTLRCompute_UsageExportLocation to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsSetUsageExportBucket
 */
+ (instancetype)queryWithObject:(GTLRCompute_UsageExportLocation *)object
                        project:(NSString *)project;

@end

/**
 *  Deletes the specified autoscaler.
 *
 *  Method: compute.regionAutoscalers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersDeleteWithproject:region:autoscaler:]

/** Name of the autoscaler to delete. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param autoscaler Name of the autoscaler to delete.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Returns the specified autoscaler.
 *
 *  Method: compute.regionAutoscalers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionAutoscalersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersGetWithproject:region:autoscaler:]

/** Name of the autoscaler to return. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Autoscaler.
 *
 *  Returns the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param autoscaler Name of the autoscaler to return.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.regionAutoscalers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of autoscalers contained within the specified region.
 *
 *  Method: compute.regionAutoscalers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionAutoscalersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionAutoscalerList.
 *
 *  Retrieves a list of autoscalers contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.regionAutoscalers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersPatchWithObject:project:region:]

/** Name of the autoscaler to patch. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.regionAutoscalers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionAutoscalersUpdateWithObject:project:region:]

/** Name of the autoscaler to update. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Deletes the specified regional BackendService resource.
 *
 *  Method: compute.regionBackendServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesDeleteWithproject:region:backendService:]

/** Name of the BackendService resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified regional BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to delete.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  backendService:(NSString *)backendService;

@end

/**
 *  Returns the specified regional BackendService resource.
 *
 *  Method: compute.regionBackendServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesGetWithproject:region:backendService:]

/** Name of the BackendService resource to return. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendService.
 *
 *  Returns the specified regional BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to return.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  backendService:(NSString *)backendService;

@end

/**
 *  Gets the most recent health check results for this regional BackendService.
 *
 *  Method: compute.regionBackendServices.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesGetHealthWithObject:project:region:backendService:]

/** Name of the BackendService resource for which to get health. */
@property(nonatomic, copy, nullable) NSString *backendService;

@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendServiceGroupHealth.
 *
 *  Gets the most recent health check results for this regional BackendService.
 *
 *  @param object The @c GTLRCompute_ResourceGroupReference to include in the
 *    query.
 *  @param project NSString
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource for which to get
 *    health.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourceGroupReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Creates a regional BackendService resource in the specified project using
 *  the data included in the request. There are several restrictions and
 *  guidelines to keep in mind when creating a regional backend service. Read
 *  Restrictions and Guidelines for more information.
 *
 *  Method: compute.regionBackendServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a regional BackendService resource in the specified project using
 *  the data included in the request. There are several restrictions and
 *  guidelines to keep in mind when creating a regional backend service. Read
 *  Restrictions and Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of regional BackendService resources available to the
 *  specified project in the given region.
 *
 *  Method: compute.regionBackendServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendServiceList.
 *
 *  Retrieves the list of regional BackendService resources available to the
 *  specified project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information. This method supports PATCH semantics and
 *  uses the JSON merge patch format and processing rules.
 *
 *  Method: compute.regionBackendServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesPatchWithObject:project:region:backendService:]

/** Name of the BackendService resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information. This method supports PATCH semantics and
 *  uses the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to patch.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  Method: compute.regionBackendServices.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionBackendServicesUpdateWithObject:project:region:backendService:]

/** Name of the BackendService resource to update. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when updating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves an aggregated list of commitments.
 *
 *  Method: compute.regionCommitments.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_CommitmentAggregatedList.
 *
 *  Retrieves an aggregated list of commitments.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified commitment resource. Gets a list of available
 *  commitments by making a list() request.
 *
 *  Method: compute.regionCommitments.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsGetWithproject:region:commitment:]

/** Name of the commitment to return. */
@property(nonatomic, copy, nullable) NSString *commitment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Commitment.
 *
 *  Returns the specified commitment resource. Gets a list of available
 *  commitments by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param commitment Name of the commitment to return.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      commitment:(NSString *)commitment;

@end

/**
 *  Creates a commitment in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.regionCommitments.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionCommitmentsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a commitment in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Commitment to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Commitment *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of commitments contained within the specified region.
 *
 *  Method: compute.regionCommitments.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionCommitmentsListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_CommitmentList.
 *
 *  Retrieves a list of commitments contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Creates a snapshot of this regional disk.
 *
 *  Method: compute.regionDisks.createSnapshot
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksCreateSnapshot : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksCreateSnapshotWithObject:project:region:disk:]

/** Name of the regional persistent disk to snapshot. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a snapshot of this regional disk.
 *
 *  @param object The @c GTLRCompute_Snapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk to snapshot.
 *
 *  @return GTLRComputeQuery_RegionDisksCreateSnapshot
 */
+ (instancetype)queryWithObject:(GTLRCompute_Snapshot *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Deletes the specified regional persistent disk. Deleting a regional disk
 *  removes all the replicas of its data permanently and is irreversible.
 *  However, deleting a disk does not delete any snapshots previously made from
 *  the disk. You must separately delete snapshots.
 *
 *  Method: compute.regionDisks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksDeleteWithproject:region:disk:]

/** Name of the regional persistent disk to delete. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified regional persistent disk. Deleting a regional disk
 *  removes all the replicas of its data permanently and is irreversible.
 *  However, deleting a disk does not delete any snapshots previously made from
 *  the disk. You must separately delete snapshots.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk to delete.
 *
 *  @return GTLRComputeQuery_RegionDisksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                            disk:(NSString *)disk;

@end

/**
 *  Returns a specified regional persistent disk.
 *
 *  Method: compute.regionDisks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDisksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksGetWithproject:region:disk:]

/** Name of the regional persistent disk to return. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Disk.
 *
 *  Returns a specified regional persistent disk.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk to return.
 *
 *  @return GTLRComputeQuery_RegionDisksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                            disk:(NSString *)disk;

@end

/**
 *  Creates a persistent regional disk in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.regionDisks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Optional. Source image to restore onto a disk. */
@property(nonatomic, copy, nullable) NSString *sourceImage;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a persistent regional disk in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of persistent disks contained within the specified
 *  region.
 *
 *  Method: compute.regionDisks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDisksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_DiskList.
 *
 *  Retrieves the list of persistent disks contained within the specified
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Resizes the specified regional persistent disk.
 *
 *  Method: compute.regionDisks.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksResizeWithObject:project:region:disk:]

/** Name of the regional persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** The project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the specified regional persistent disk.
 *
 *  @param object The @c GTLRCompute_RegionDisksResizeRequest to include in the
 *    query.
 *  @param project The project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk.
 *
 *  @return GTLRComputeQuery_RegionDisksResize
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionDisksResizeRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Sets the labels on the target regional disk.
 *
 *  Method: compute.regionDisks.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksSetLabelsWithObject:project:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on the target regional disk.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.regionDisks.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDisksTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDisksTestIamPermissionsWithObject:project:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns the specified regional disk type. Gets a list of available disk
 *  types by making a list() request.
 *
 *  Method: compute.regionDiskTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDiskTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDiskTypesGetWithproject:region:diskType:]

/** Name of the disk type to return. */
@property(nonatomic, copy, nullable) NSString *diskType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_DiskType.
 *
 *  Returns the specified regional disk type. Gets a list of available disk
 *  types by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param diskType Name of the disk type to return.
 *
 *  @return GTLRComputeQuery_RegionDiskTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        diskType:(NSString *)diskType;

@end

/**
 *  Retrieves a list of regional disk types available to the specified project.
 *
 *  Method: compute.regionDiskTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDiskTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionDiskTypesListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionDiskTypeList.
 *
 *  Retrieves a list of regional disk types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionDiskTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Flags the specified instances to be immediately removed from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.abandonInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersAbandonInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersAbandonInstancesWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances to be immediately removed from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersAbandonInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Deletes the specified managed instance group and all of the instances in
 *  that group.
 *
 *  Method: compute.regionInstanceGroupManagers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersDeleteWithproject:region:instanceGroupManager:]

/** Name of the managed instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified managed instance group and all of the instances in
 *  that group.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group to delete.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately deleted. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. The
 *  deleteInstances operation is marked DONE if the deleteInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the deleting action with the listmanagedinstances
 *  method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.deleteInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersDeleteInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersDeleteInstancesWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately deleted. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. The
 *  deleteInstances operation is marked DONE if the deleteInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the deleting action with the listmanagedinstances
 *  method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersDeleteInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns all of the details about the specified managed instance group.
 *
 *  Method: compute.regionInstanceGroupManagers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersGetWithproject:region:instanceGroupManager:]

/** Name of the managed instance group to return. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManager.
 *
 *  Returns all of the details about the specified managed instance group.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group to return.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method.
 *  A regional managed instance group can contain up to 2000 instances.
 *
 *  Method: compute.regionInstanceGroupManagers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method.
 *  A regional managed instance group can contain up to 2000 instances.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of managed instance groups that are contained within the
 *  specified region.
 *
 *  Method: compute.regionInstanceGroupManagers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagerList.
 *
 *  Retrieves the list of managed instance groups that are contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists the instances in the managed instance group and instances that are
 *  scheduled to be created. The list includes any current actions that the
 *  group has scheduled for its instances.
 *
 *  Method: compute.regionInstanceGroupManagers.listManagedInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersListManagedInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersListManagedInstancesWithproject:region:instanceGroupManager:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagersListInstancesResponse.
 *
 *  Lists the instances in the managed instance group and instances that are
 *  scheduled to be created. The list includes any current actions that the
 *  group has scheduled for its instances.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersListManagedInstances
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listmanagedinstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules.
 *
 *  Method: compute.regionInstanceGroupManagers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersPatchWithObject:project:region:instanceGroupManager:]

/** The name of the instance group manager. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listmanagedinstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the instance group manager.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately recreated. The instances are deleted and recreated using the
 *  current instance template for the managed instance group. This operation is
 *  marked as DONE when the flag is set even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.recreateInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersRecreateInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersRecreateInstancesWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately recreated. The instances are deleted and recreated using the
 *  current instance template for the managed instance group. This operation is
 *  marked as DONE when the flag is set even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupManagersRecreateRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersRecreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersRecreateRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Changes the intended size of the managed instance group. If you increase the
 *  size, the group creates new instances using the current instance template.
 *  If you decrease the size, the group deletes one or more instances.
 *  The resize operation is marked DONE if the resize request is successful. The
 *  underlying actions take additional time. You must separately verify the
 *  status of the creating or deleting actions with the listmanagedinstances
 *  method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  Method: compute.regionInstanceGroupManagers.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersResizeWithproject:region:instanceGroupManager:size:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Number of instances that should exist in this instance group manager. */
@property(nonatomic, assign) NSInteger size;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the intended size of the managed instance group. If you increase the
 *  size, the group creates new instances using the current instance template.
 *  If you decrease the size, the group deletes one or more instances.
 *  The resize operation is marked DONE if the resize request is successful. The
 *  underlying actions take additional time. You must separately verify the
 *  status of the creating or deleting actions with the listmanagedinstances
 *  method.
 *  If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is removed or deleted.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *  @param size Number of instances that should exist in this instance group
 *    manager.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersResize
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager
                            size:(NSInteger)size;

@end

/**
 *  Sets the instance template to use when creating new instances or recreating
 *  instances in this group. Existing instances are not affected.
 *
 *  Method: compute.regionInstanceGroupManagers.setInstanceTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersSetInstanceTemplate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersSetInstanceTemplateWithObject:project:region:instanceGroupManager:]

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the instance template to use when creating new instances or recreating
 *  instances in this group. Existing instances are not affected.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersSetInstanceTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Modifies the target pools to which all new instances in this group are
 *  assigned. Existing instances in the group are not affected.
 *
 *  Method: compute.regionInstanceGroupManagers.setTargetPools
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersSetTargetPools : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupManagersSetTargetPoolsWithObject:project:region:instanceGroupManager:]

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modifies the target pools to which all new instances in this group are
 *  assigned. Existing instances in the group are not affected.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersSetTargetPools
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns the specified instance group resource.
 *
 *  Method: compute.regionInstanceGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsGetWithproject:region:instanceGroup:]

/** Name of the instance group resource to return. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstanceGroup.
 *
 *  Returns the specified instance group resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup Name of the instance group resource to return.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Retrieves the list of instance group resources contained within the
 *  specified region.
 *
 *  Method: compute.regionInstanceGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupList.
 *
 *  Retrieves the list of instance group resources contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists the instances in the specified instance group and displays information
 *  about the named ports. Depending on the specified options, this method can
 *  list all instances or only the instances that are running.
 *
 *  Method: compute.regionInstanceGroups.listInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsListInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsListInstancesWithObject:project:region:instanceGroup:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Name of the regional instance group for which we want to list the instances.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupsListInstances.
 *
 *  Lists the instances in the specified instance group and displays information
 *  about the named ports. Depending on the specified options, this method can
 *  list all instances or only the instances that are running.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupsListInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup Name of the regional instance group for which we want
 *    to list the instances.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsListInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupsListInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Sets the named ports for the specified regional instance group.
 *
 *  Method: compute.regionInstanceGroups.setNamedPorts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupsSetNamedPorts : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionInstanceGroupsSetNamedPortsWithObject:project:region:instanceGroup:]

/**
 *  The name of the regional instance group where the named ports are updated.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the named ports for the specified regional instance group.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup The name of the regional instance group where the named
 *    ports are updated.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsSetNamedPorts
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Deletes the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsDeleteWithproject:region:operation:]

/** Name of the Operations resource to delete. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @return GTLRComputeQuery_RegionOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsGetWithproject:region:operation:]

/** Name of the Operations resource to return. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @return GTLRComputeQuery_RegionOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  Method: compute.regionOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Returns the specified Region resource. Gets a list of available regions by
 *  making a list() request.
 *
 *  Method: compute.regions.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionsGetWithproject:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region resource to return. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Region.
 *
 *  Returns the specified Region resource. Gets a list of available regions by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region resource to return.
 *
 *  @return GTLRComputeQuery_RegionsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves the list of region resources available to the specified project.
 *
 *  Method: compute.regions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RegionList.
 *
 *  Retrieves the list of region resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RegionsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Retrieves an aggregated list of routers.
 *
 *  Method: compute.routers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RouterAggregatedList.
 *
 *  Retrieves an aggregated list of routers.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RoutersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Router resource.
 *
 *  Method: compute.routers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersDeleteWithproject:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to delete. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Router resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to delete.
 *
 *  @return GTLRComputeQuery_RoutersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Returns the specified Router resource. Gets a list of available routers by
 *  making a list() request.
 *
 *  Method: compute.routers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersGetWithproject:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to return. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Router.
 *
 *  Returns the specified Router resource. Gets a list of available routers by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to return.
 *
 *  @return GTLRComputeQuery_RoutersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Retrieves runtime Nat mapping information of VM endpoints.
 *
 *  Method: compute.routers.getNatMappingInfo
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGetNatMappingInfo : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersGetNatMappingInfoWithproject:region:router:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Name of the Router resource to query for Nat Mapping information of VM
 *  endpoints.
 */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_VmEndpointNatMappingsList.
 *
 *  Retrieves runtime Nat mapping information of VM endpoints.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query for Nat Mapping
 *    information of VM endpoints.
 *
 *  @return GTLRComputeQuery_RoutersGetNatMappingInfo
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Retrieves runtime information of the specified router.
 *
 *  Method: compute.routers.getRouterStatus
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGetRouterStatus : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersGetRouterStatusWithproject:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to query. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_RouterStatusResponse.
 *
 *  Retrieves runtime information of the specified router.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query.
 *
 *  @return GTLRComputeQuery_RoutersGetRouterStatus
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Creates a Router resource in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.routers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Router resource in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RoutersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of Router resources available to the specified project.
 *
 *  Method: compute.routers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_RouterList.
 *
 *  Retrieves a list of Router resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RoutersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  Method: compute.routers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersPatchWithObject:project:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to patch. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to patch.
 *
 *  @return GTLRComputeQuery_RoutersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Preview fields auto-generated during router create and update operations.
 *  Calling this method does NOT create or update the router.
 *
 *  Method: compute.routers.preview
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersPreview : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersPreviewWithObject:project:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to query. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_RoutersPreviewResponse.
 *
 *  Preview fields auto-generated during router create and update operations.
 *  Calling this method does NOT create or update the router.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query.
 *
 *  @return GTLRComputeQuery_RoutersPreview
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Updates the specified Router resource with the data included in the request.
 *
 *  Method: compute.routers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutersUpdateWithObject:project:region:router:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to update. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified Router resource with the data included in the request.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to update.
 *
 *  @return GTLRComputeQuery_RoutersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Deletes the specified Route resource.
 *
 *  Method: compute.routes.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesDeleteWithproject:route:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Route resource to delete. */
@property(nonatomic, copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Route resource.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to delete.
 *
 *  @return GTLRComputeQuery_RoutesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Returns the specified Route resource. Gets a list of available routes by
 *  making a list() request.
 *
 *  Method: compute.routes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesGetWithproject:route:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the Route resource to return. */
@property(nonatomic, copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Route.
 *
 *  Returns the specified Route resource. Gets a list of available routes by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to return.
 *
 *  @return GTLRComputeQuery_RoutesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.routes.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Route to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RoutesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Route *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  Method: compute.routes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RouteList.
 *
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RoutesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Inserts a rule into a security policy.
 *
 *  Method: compute.securityPolicies.addRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesAddRule : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesAddRuleWithObject:project:securityPolicy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts a rule into a security policy.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesAddRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyRule *)object
                        project:(NSString *)project
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Deletes the specified policy.
 *
 *  Method: compute.securityPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesDeleteWithproject:securityPolicy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the security policy to delete. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified policy.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to delete.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  List all of the ordered rules present in a single specified policy.
 *
 *  Method: compute.securityPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesGetWithproject:securityPolicy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to get. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicy.
 *
 *  List all of the ordered rules present in a single specified policy.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to get.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Gets a rule at the specified priority.
 *
 *  Method: compute.securityPolicies.getRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesGetRule : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesGetRuleWithproject:securityPolicy:]

/** The priority of the rule to get from the security policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to which the queried rule belongs. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicyRule.
 *
 *  Gets a rule at the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to which the queried rule
 *    belongs.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesGetRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.securityPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_SecurityPolicy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicy *)object
                        project:(NSString *)project;

@end

/**
 *  List all the policies that have been configured for the specified project.
 *
 *  Method: compute.securityPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicyList.
 *
 *  List all the policies that have been configured for the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified policy with the data included in the request.
 *
 *  Method: compute.securityPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesPatchWithObject:project:securityPolicy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified policy with the data included in the request.
 *
 *  @param object The @c GTLRCompute_SecurityPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicy *)object
                        project:(NSString *)project
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Patches a rule at the specified priority.
 *
 *  Method: compute.securityPolicies.patchRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesPatchRule : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesPatchRuleWithObject:project:securityPolicy:]

/** The priority of the rule to patch. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches a rule at the specified priority.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesPatchRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyRule *)object
                        project:(NSString *)project
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Deletes a rule at the specified priority.
 *
 *  Method: compute.securityPolicies.removeRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesRemoveRule : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSecurityPoliciesRemoveRuleWithproject:securityPolicy:]

/** The priority of the rule to remove from the security policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a rule at the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesRemoveRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot.
 *  For more information, see Deleting snapshots.
 *
 *  Method: compute.snapshots.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsDeleteWithproject:snapshot:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Snapshot resource to delete. */
@property(nonatomic, copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot.
 *  For more information, see Deleting snapshots.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to delete.
 *
 *  @return GTLRComputeQuery_SnapshotsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Returns the specified Snapshot resource. Gets a list of available snapshots
 *  by making a list() request.
 *
 *  Method: compute.snapshots.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsGetWithproject:snapshot:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the Snapshot resource to return. */
@property(nonatomic, copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Snapshot.
 *
 *  Returns the specified Snapshot resource. Gets a list of available snapshots
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to return.
 *
 *  @return GTLRComputeQuery_SnapshotsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.snapshots.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsGetIamPolicyWithproject:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  Method: compute.snapshots.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SnapshotList.
 *
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.snapshots.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsSetIamPolicyWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on a snapshot. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.snapshots.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsSetLabels : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsSetLabelsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a snapshot. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.snapshots.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsTestIamPermissionsWithObject:project:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified SslCertificate resource.
 *
 *  Method: compute.sslCertificates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesDeleteWithproject:sslCertificate:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the SslCertificate resource to delete. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SslCertificate resource.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to delete.
 *
 *  @return GTLRComputeQuery_SslCertificatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Returns the specified SslCertificate resource. Gets a list of available SSL
 *  certificates by making a list() request.
 *
 *  Method: compute.sslCertificates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesGetWithproject:sslCertificate:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the SslCertificate resource to return. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_SslCertificate.
 *
 *  Returns the specified SslCertificate resource. Gets a list of available SSL
 *  certificates by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to return.
 *
 *  @return GTLRComputeQuery_SslCertificatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.sslCertificates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_SslCertificate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslCertificatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslCertificate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  Method: compute.sslCertificates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SslCertificateList.
 *
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslCertificatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified SSL policy. The SSL policy resource can be deleted
 *  only if it is not in use by any TargetHttpsProxy or TargetSslProxy
 *  resources.
 *
 *  Method: compute.sslPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslPoliciesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslPoliciesDeleteWithproject:sslPolicy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the SSL policy to delete. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SSL policy. The SSL policy resource can be deleted
 *  only if it is not in use by any TargetHttpsProxy or TargetSslProxy
 *  resources.
 *
 *  @param project Project ID for this request.
 *  @param sslPolicy Name of the SSL policy to delete. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_SslPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                       sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Lists all of the ordered rules present in a single specified policy.
 *
 *  Method: compute.sslPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslPoliciesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslPoliciesGetWithproject:sslPolicy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the SSL policy to update. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_SslPolicy.
 *
 *  Lists all of the ordered rules present in a single specified policy.
 *
 *  @param project Project ID for this request.
 *  @param sslPolicy Name of the SSL policy to update. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_SslPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                       sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Returns the specified SSL policy resource. Gets a list of available SSL
 *  policies by making a list() request.
 *
 *  Method: compute.sslPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslPoliciesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslPoliciesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Returns the specified SSL policy resource. Gets a list of available SSL
 *  policies by making a list() request.
 *
 *  @param object The @c GTLRCompute_SslPolicy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicy *)object
                        project:(NSString *)project;

@end

/**
 *  Lists all the SSL policies that have been configured for the specified
 *  project.
 *
 *  Method: compute.sslPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslPoliciesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslPoliciesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SslPoliciesList.
 *
 *  Lists all the SSL policies that have been configured for the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Lists all features that can be specified in the SSL policy when using custom
 *  profile.
 *
 *  Method: compute.sslPolicies.listAvailableFeatures
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslPoliciesListAvailableFeatures : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslPoliciesListAvailableFeaturesWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SslPoliciesListAvailableFeaturesResponse.
 *
 *  Lists all features that can be specified in the SSL policy when using custom
 *  profile.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslPoliciesListAvailableFeatures
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified SSL policy with the data included in the request.
 *
 *  Method: compute.sslPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslPoliciesPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslPoliciesPatchWithObject:project:sslPolicy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the SSL policy to update. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified SSL policy with the data included in the request.
 *
 *  @param object The @c GTLRCompute_SslPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param sslPolicy Name of the SSL policy to update. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_SslPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicy *)object
                        project:(NSString *)project
                      sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Retrieves an aggregated list of subnetworks.
 *
 *  Method: compute.subnetworks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SubnetworkAggregatedList.
 *
 *  Retrieves an aggregated list of subnetworks.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified subnetwork.
 *
 *  Method: compute.subnetworks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksDeleteWithproject:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to delete. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified subnetwork.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to delete.
 *
 *  @return GTLRComputeQuery_SubnetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Expands the IP CIDR range of the subnetwork to a specified value.
 *
 *  Method: compute.subnetworks.expandIpCidrRange
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksExpandIpCidrRange : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksExpandIpCidrRangeWithObject:project:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to update. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Expands the IP CIDR range of the subnetwork to a specified value.
 *
 *  @param object The @c GTLRCompute_SubnetworksExpandIpCidrRangeRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to update.
 *
 *  @return GTLRComputeQuery_SubnetworksExpandIpCidrRange
 */
+ (instancetype)queryWithObject:(GTLRCompute_SubnetworksExpandIpCidrRangeRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Returns the specified subnetwork. Gets a list of available subnetworks
 *  list() request.
 *
 *  Method: compute.subnetworks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksGetWithproject:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Subnetwork resource to return. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Subnetwork.
 *
 *  Returns the specified subnetwork. Gets a list of available subnetworks
 *  list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to return.
 *
 *  @return GTLRComputeQuery_SubnetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.subnetworks.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksGetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksGetIamPolicyWithproject:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.subnetworks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Subnetwork to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_SubnetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Subnetwork *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  Method: compute.subnetworks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_SubnetworkList.
 *
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_SubnetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves an aggregated list of usable subnetworks.
 *
 *  Method: compute.subnetworks.listUsable
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksListUsable : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksListUsableWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_UsableSubnetworksAggregatedList.
 *
 *  Retrieves an aggregated list of usable subnetworks.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksListUsable
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified subnetwork with the data included in the request. Only
 *  certain fields can up updated with a patch request as indicated in the field
 *  descriptions. You must specify the current fingeprint of the subnetwork
 *  resource being patched.
 *
 *  Method: compute.subnetworks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksPatchWithObject:project:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to patch. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified subnetwork with the data included in the request. Only
 *  certain fields can up updated with a patch request as indicated in the field
 *  descriptions. You must specify the current fingeprint of the subnetwork
 *  resource being patched.
 *
 *  @param object The @c GTLRCompute_Subnetwork to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to patch.
 *
 *  @return GTLRComputeQuery_SubnetworksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Subnetwork *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.subnetworks.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksSetIamPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksSetIamPolicyWithObject:project:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Set whether VMs in this subnet can access Google services without assigning
 *  external IP addresses through Private Google Access.
 *
 *  Method: compute.subnetworks.setPrivateIpGoogleAccess
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksSetPrivateIpGoogleAccess : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksSetPrivateIpGoogleAccessWithObject:project:region:subnetwork:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Set whether VMs in this subnet can access Google services without assigning
 *  external IP addresses through Private Google Access.
 *
 *  @param object The @c GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource.
 *
 *  @return GTLRComputeQuery_SubnetworksSetPrivateIpGoogleAccess
 */
+ (instancetype)queryWithObject:(GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.subnetworks.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksTestIamPermissions : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksTestIamPermissionsWithObject:project:region:resource:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  Method: compute.targetHttpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesDeleteWithproject:targetHttpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Returns the specified TargetHttpProxy resource. Gets a list of available
 *  target HTTP proxies by making a list() request.
 *
 *  Method: compute.targetHttpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesGetWithproject:targetHttpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetHttpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxy.
 *
 *  Returns the specified TargetHttpProxy resource. Gets a list of available
 *  target HTTP proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxyList.
 *
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the URL map for TargetHttpProxy.
 *
 *  Method: compute.targetHttpProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesSetUrlMap : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesSetUrlMapWithObject:project:targetHttpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy to set a URL map for. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy to set a URL map for.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
                targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  Method: compute.targetHttpsProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesDeleteWithproject:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Returns the specified TargetHttpsProxy resource. Gets a list of available
 *  target HTTPS proxies by making a list() request.
 *
 *  Method: compute.targetHttpsProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesGetWithproject:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetHttpsProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxy.
 *
 *  Returns the specified TargetHttpsProxy resource. Gets a list of available
 *  target HTTPS proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpsProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpsProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxyList.
 *
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the QUIC override policy for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setQuicOverride
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetQuicOverride : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetQuicOverrideWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource to set the QUIC override policy for.
 *  The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the QUIC override policy for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxiesSetQuicOverrideRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to set the
 *    QUIC override policy for. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetQuicOverride
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxiesSetQuicOverrideRequest *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetSslCertificatesWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource to set an SslCertificates resource
 *  for.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to set an
 *    SslCertificates resource for.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the HTTPS proxy load balancer. They do not affect the connection
 *  between the load balancer and the backends.
 *
 *  Method: compute.targetHttpsProxies.setSslPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetSslPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetSslPolicyWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource whose SSL policy is to be set. The
 *  name must be 1-63 characters long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the HTTPS proxy load balancer. They do not affect the connection
 *  between the load balancer and the backends.
 *
 *  @param object The @c GTLRCompute_SslPolicyReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource whose SSL
 *    policy is to be set. The name must be 1-63 characters long, and comply
 *    with RFC1035.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetSslPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicyReference *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetUrlMap : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetUrlMapWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource whose URL map is to be set. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource whose URL map
 *    is to be set.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Retrieves an aggregated list of target instances.
 *
 *  Method: compute.targetInstances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceAggregatedList.
 *
 *  Retrieves an aggregated list of target instances.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetInstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified TargetInstance resource.
 *
 *  Method: compute.targetInstances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesDeleteWithproject:zoneProperty:targetInstance:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetInstance resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetInstance resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to delete.
 *
 *  @return GTLRComputeQuery_TargetInstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Returns the specified TargetInstance resource. Gets a list of available
 *  target instances by making a list() request.
 *
 *  Method: compute.targetInstances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesGetWithproject:zoneProperty:targetInstance:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetInstance resource to return. */
@property(nonatomic, copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstance.
 *
 *  Returns the specified TargetInstance resource. Gets a list of available
 *  target instances by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to return.
 *
 *  @return GTLRComputeQuery_TargetInstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  Method: compute.targetInstances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetInstance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @return GTLRComputeQuery_TargetInstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetInstance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  Method: compute.targetInstances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceList.
 *
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @return GTLRComputeQuery_TargetInstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Adds health check URLs to a target pool.
 *
 *  Method: compute.targetPools.addHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddHealthCheck : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAddHealthCheckWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target pool to add a health check to. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds health check URLs to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddHealthCheckRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the target pool to add a health check to.
 *
 *  @return GTLRComputeQuery_TargetPoolsAddHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Adds an instance to a target pool.
 *
 *  Method: compute.targetPools.addInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAddInstanceWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to add instances to. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an instance to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddInstanceRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to add instances to.
 *
 *  @return GTLRComputeQuery_TargetPoolsAddInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Retrieves an aggregated list of target pools.
 *
 *  Method: compute.targetPools.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetPoolAggregatedList.
 *
 *  Retrieves an aggregated list of target pools.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetPoolsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target pool.
 *
 *  Method: compute.targetPools.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsDeleteWithproject:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target pool.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to delete.
 *
 *  @return GTLRComputeQuery_TargetPoolsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Returns the specified target pool. Gets a list of available target pools by
 *  making a list() request.
 *
 *  Method: compute.targetPools.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsGetWithproject:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetPool resource to return. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPool.
 *
 *  Returns the specified target pool. Gets a list of available target pools by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to return.
 *
 *  @return GTLRComputeQuery_TargetPoolsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  Method: compute.targetPools.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsGetHealthWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetPool resource to which the queried instance belongs. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPoolInstanceHealth.
 *
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  @param object The @c GTLRCompute_InstanceReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to which the queried
 *    instance belongs.
 *
 *  @return GTLRComputeQuery_TargetPoolsGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.targetPools.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetPool to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_TargetPoolsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPool *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  Method: compute.targetPools.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_TargetPoolList.
 *
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_TargetPoolsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Removes health check URL from a target pool.
 *
 *  Method: compute.targetPools.removeHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveHealthCheck : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsRemoveHealthCheckWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target pool to remove health checks from. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes health check URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveHealthCheckRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetPool Name of the target pool to remove health checks from.
 *
 *  @return GTLRComputeQuery_TargetPoolsRemoveHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Removes instance URL from a target pool.
 *
 *  Method: compute.targetPools.removeInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsRemoveInstanceWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to remove instances from. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes instance URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveInstanceRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to remove instances from.
 *
 *  @return GTLRComputeQuery_TargetPoolsRemoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Changes a backup target pool's configurations.
 *
 *  Method: compute.targetPools.setBackup
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsSetBackup : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsSetBackupWithObject:project:region:targetPool:]

/** New failoverRatio value for the target pool. */
@property(nonatomic, assign) float failoverRatio;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to set a backup pool for. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes a backup target pool's configurations.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to set a backup pool for.
 *
 *  @return GTLRComputeQuery_TargetPoolsSetBackup
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Deletes the specified TargetSslProxy resource.
 *
 *  Method: compute.targetSslProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesDeleteWithproject:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetSslProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetSslProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Returns the specified TargetSslProxy resource. Gets a list of available
 *  target SSL proxies by making a list() request.
 *
 *  Method: compute.targetSslProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetSslProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesGetWithproject:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetSslProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_TargetSslProxy.
 *
 *  Returns the specified TargetSslProxy resource. Gets a list of available
 *  target SSL proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Creates a TargetSslProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetSslProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetSslProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetSslProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetSslProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetSslProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetSslProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetSslProxyList.
 *
 *  Retrieves the list of TargetSslProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the BackendService for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setBackendService
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetBackendService : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesSetBackendServiceWithObject:project:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose BackendService resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the BackendService for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetBackendServiceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose
 *    BackendService resource is to be set.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetBackendService
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetBackendServiceRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Changes the ProxyHeaderType for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setProxyHeader
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetProxyHeader : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesSetProxyHeaderWithObject:project:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetSslProxy resource whose ProxyHeader is to be set. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the ProxyHeaderType for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetProxyHeaderRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose ProxyHeader
 *    is to be set.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetProxyHeader
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetProxyHeaderRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Changes SslCertificates for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetSslCertificates : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesSetSslCertificatesWithObject:project:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose SslCertificate resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes SslCertificates for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetSslCertificatesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose
 *    SslCertificate resource is to be set.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the SSL proxy load balancer. They do not affect the connection
 *  between the load balancer and the backends.
 *
 *  Method: compute.targetSslProxies.setSslPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetSslPolicy : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetSslProxiesSetSslPolicyWithObject:project:targetSslProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose SSL policy is to be set. The name
 *  must be 1-63 characters long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the SSL proxy load balancer. They do not affect the connection
 *  between the load balancer and the backends.
 *
 *  @param object The @c GTLRCompute_SslPolicyReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose SSL policy
 *    is to be set. The name must be 1-63 characters long, and comply with
 *    RFC1035.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetSslPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicyReference *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  Method: compute.targetTcpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesDeleteWithproject:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetTcpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Returns the specified TargetTcpProxy resource. Gets a list of available
 *  target TCP proxies by making a list() request.
 *
 *  Method: compute.targetTcpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetTcpProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesGetWithproject:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetTcpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxy.
 *
 *  Returns the specified TargetTcpProxy resource. Gets a list of available
 *  target TCP proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Creates a TargetTcpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetTcpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetTcpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetTcpProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetTcpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetTcpProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxyList.
 *
 *  Retrieves the list of TargetTcpProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the BackendService for TargetTcpProxy.
 *
 *  Method: compute.targetTcpProxies.setBackendService
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesSetBackendService : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesSetBackendServiceWithObject:project:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetTcpProxy resource whose BackendService resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the BackendService for TargetTcpProxy.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxiesSetBackendServiceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource whose
 *    BackendService resource is to be set.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesSetBackendService
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxiesSetBackendServiceRequest *)object
                        project:(NSString *)project
                 targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Changes the ProxyHeaderType for TargetTcpProxy.
 *
 *  Method: compute.targetTcpProxies.setProxyHeader
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesSetProxyHeader : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetTcpProxiesSetProxyHeaderWithObject:project:targetTcpProxy:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetTcpProxy resource whose ProxyHeader is to be set. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the ProxyHeaderType for TargetTcpProxy.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource whose ProxyHeader
 *    is to be set.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesSetProxyHeader
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest *)object
                        project:(NSString *)project
                 targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Retrieves an aggregated list of target VPN gateways.
 *
 *  Method: compute.targetVpnGateways.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayAggregatedList.
 *
 *  Retrieves an aggregated list of target VPN gateways.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target VPN gateway.
 *
 *  Method: compute.targetVpnGateways.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysDeleteWithproject:region:targetVpnGateway:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target VPN gateway to delete. */
@property(nonatomic, copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to delete.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Returns the specified target VPN gateway. Gets a list of available target
 *  VPN gateways by making a list() request.
 *
 *  Method: compute.targetVpnGateways.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysGetWithproject:region:targetVpnGateway:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the target VPN gateway to return. */
@property(nonatomic, copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGateway.
 *
 *  Returns the specified target VPN gateway. Gets a list of available target
 *  VPN gateways by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to return.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.targetVpnGateways.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetVpnGateway to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetVpnGateway *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  Method: compute.targetVpnGateways.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayList.
 *
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified UrlMap resource.
 *
 *  Method: compute.urlMaps.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsDeleteWithproject:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to delete. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified UrlMap resource.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to delete.
 *
 *  @return GTLRComputeQuery_UrlMapsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Returns the specified UrlMap resource. Gets a list of available URL maps by
 *  making a list() request.
 *
 *  Method: compute.urlMaps.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsGetWithproject:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the UrlMap resource to return. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMap.
 *
 *  Returns the specified UrlMap resource. Gets a list of available URL maps by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to return.
 *
 *  @return GTLRComputeQuery_UrlMapsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.urlMaps.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsInsertWithObject:project:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_UrlMapsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project;

@end

/**
 *  Initiates a cache invalidation operation, invalidating the specified path,
 *  scoped to the specified UrlMap.
 *
 *  Method: compute.urlMaps.invalidateCache
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsInvalidateCache : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsInvalidateCacheWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap scoping this request. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Initiates a cache invalidation operation, invalidating the specified path,
 *  scoped to the specified UrlMap.
 *
 *  @param object The @c GTLRCompute_CacheInvalidationRule to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap scoping this request.
 *
 *  @return GTLRComputeQuery_UrlMapsInvalidateCache
 */
+ (instancetype)queryWithObject:(GTLRCompute_CacheInvalidationRule *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  Method: compute.urlMaps.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_UrlMapList.
 *
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_UrlMapsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.urlMaps.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsPatchWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to patch. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to patch.
 *
 *  @return GTLRComputeQuery_UrlMapsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  Method: compute.urlMaps.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsUpdateWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to update. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to update.
 *
 *  @return GTLRComputeQuery_UrlMapsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  Method: compute.urlMaps.validate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsValidate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsValidateWithObject:project:urlMap:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the UrlMap resource to be validated as. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMapsValidateResponse.
 *
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  @param object The @c GTLRCompute_UrlMapsValidateRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to be validated as.
 *
 *  @return GTLRComputeQuery_UrlMapsValidate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapsValidateRequest *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves an aggregated list of VPN tunnels.
 *
 *  Method: compute.vpnTunnels.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsAggregatedListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelAggregatedList.
 *
 *  Retrieves an aggregated list of VPN tunnels.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_VpnTunnelsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified VpnTunnel resource.
 *
 *  Method: compute.vpnTunnels.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsDeleteWithproject:region:vpnTunnel:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the VpnTunnel resource to delete. */
@property(nonatomic, copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified VpnTunnel resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to delete.
 *
 *  @return GTLRComputeQuery_VpnTunnelsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Returns the specified VpnTunnel resource. Gets a list of available VPN
 *  tunnels by making a list() request.
 *
 *  Method: compute.vpnTunnels.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsGetWithproject:region:vpnTunnel:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the VpnTunnel resource to return. */
@property(nonatomic, copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_VpnTunnel.
 *
 *  Returns the specified VpnTunnel resource. Gets a list of available VPN
 *  tunnels by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to return.
 *
 *  @return GTLRComputeQuery_VpnTunnelsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.vpnTunnels.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check if original operation with the same request ID was
 *  received, and if so, will ignore the second request. This prevents clients
 *  from accidentally creating duplicate commitments.
 *  The request ID must be a valid UUID with the exception that zero UUID is not
 *  supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_VpnTunnel to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_VpnTunnelsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_VpnTunnel *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  Method: compute.vpnTunnels.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsListWithproject:region:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelList.
 *
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_VpnTunnelsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ZoneOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsDeleteWithproject:zoneProperty:operation:]

/** Name of the Operations resource to delete. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @return GTLRComputeQuery_ZoneOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsGetWithproject:zoneProperty:operation:]

/** Name of the Operations resource to return. */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @return GTLRComputeQuery_ZoneOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  Method: compute.zoneOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsListWithproject:zoneProperty:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for request.
 *
 *  @return GTLRComputeQuery_ZoneOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Returns the specified Zone resource. Gets a list of available zones by
 *  making a list() request.
 *
 *  Method: compute.zones.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZonesGetWithproject:zoneProperty:]

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone resource to return.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Zone.
 *
 *  Returns the specified Zone resource. Gets a list of available zones by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone resource to return.
 *
 *  @return GTLRComputeQuery_ZonesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  Method: compute.zones.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZonesListWithproject:]

/**
 *  A filter expression that filters resources listed in the response. The
 *  expression must specify the field name, a comparison operator, and the value
 *  that you want to use for filtering. The value must be a string, a number, or
 *  a boolean. The comparison operator must be either =, !=, >, or <.
 *  For example, if you are filtering Compute Engine instances, you can exclude
 *  instances named example-instance by specifying name != example-instance.
 *  You can also filter nested fields. For example, you could specify
 *  scheduling.automaticRestart = false to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels.
 *  To filter on multiple expressions, provide each separate expression within
 *  parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform
 *  = "Intel Skylake"). By default, each expression is an AND expression.
 *  However, you can include AND and OR expressions explicitly. For example,
 *  (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests. Acceptable values are 0 to 500, inclusive.
 *  (Default: 500)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name.
 *  You can also sort results in descending order based on the creation
 *  timestamp using orderBy="creationTimestamp desc". This sorts results based
 *  on the creationTimestamp field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first.
 *  Currently, only sorting by name or creationTimestamp desc is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ZoneList.
 *
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ZonesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
