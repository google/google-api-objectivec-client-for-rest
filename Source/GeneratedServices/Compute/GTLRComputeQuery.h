// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Compute Engine API (compute/v1)
// Description:
//   Creates and runs virtual machines on Google Cloud Platform.
// Documentation:
//   https://developers.google.com/compute/docs/reference/latest/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRQuery.h"
#else
  #import "GTLRQuery.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCompute_AccessConfig;
@class GTLRCompute_Address;
@class GTLRCompute_AttachedDisk;
@class GTLRCompute_Autoscaler;
@class GTLRCompute_BackendService;
@class GTLRCompute_DeprecationStatus;
@class GTLRCompute_Disk;
@class GTLRCompute_DiskMoveRequest;
@class GTLRCompute_DisksResizeRequest;
@class GTLRCompute_Firewall;
@class GTLRCompute_ForwardingRule;
@class GTLRCompute_HttpHealthCheck;
@class GTLRCompute_HttpsHealthCheck;
@class GTLRCompute_Image;
@class GTLRCompute_Instance;
@class GTLRCompute_InstanceGroup;
@class GTLRCompute_InstanceGroupManager;
@class GTLRCompute_InstanceGroupManagersAbandonInstancesRequest;
@class GTLRCompute_InstanceGroupManagersDeleteInstancesRequest;
@class GTLRCompute_InstanceGroupManagersRecreateInstancesRequest;
@class GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest;
@class GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest;
@class GTLRCompute_InstanceGroupsAddInstancesRequest;
@class GTLRCompute_InstanceGroupsListInstancesRequest;
@class GTLRCompute_InstanceGroupsRemoveInstancesRequest;
@class GTLRCompute_InstanceGroupsSetNamedPortsRequest;
@class GTLRCompute_InstanceMoveRequest;
@class GTLRCompute_InstanceReference;
@class GTLRCompute_InstancesSetMachineTypeRequest;
@class GTLRCompute_InstanceTemplate;
@class GTLRCompute_Metadata;
@class GTLRCompute_Network;
@class GTLRCompute_ResourceGroupReference;
@class GTLRCompute_Route;
@class GTLRCompute_Scheduling;
@class GTLRCompute_Snapshot;
@class GTLRCompute_SslCertificate;
@class GTLRCompute_Subnetwork;
@class GTLRCompute_Tags;
@class GTLRCompute_TargetHttpProxy;
@class GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest;
@class GTLRCompute_TargetHttpsProxy;
@class GTLRCompute_TargetInstance;
@class GTLRCompute_TargetPool;
@class GTLRCompute_TargetPoolsAddHealthCheckRequest;
@class GTLRCompute_TargetPoolsAddInstanceRequest;
@class GTLRCompute_TargetPoolsRemoveHealthCheckRequest;
@class GTLRCompute_TargetPoolsRemoveInstanceRequest;
@class GTLRCompute_TargetReference;
@class GTLRCompute_TargetVpnGateway;
@class GTLRCompute_UrlMap;
@class GTLRCompute_UrlMapReference;
@class GTLRCompute_UrlMapsValidateRequest;
@class GTLRCompute_UsageExportLocation;
@class GTLRCompute_VpnTunnel;

NS_ASSUME_NONNULL_BEGIN

/**
 *  Parent class for other Compute query classes.
 */
@interface GTLRComputeQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(copy, nullable) NSString *fields;

@end

/**
 *  Retrieves an aggregated list of addresses.
 *
 *  Method: compute.addresses.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AddressAggregatedList.
 *
 *  Retrieves an aggregated list of addresses.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_AddressesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.addresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesDeleteWithproject:region:address:]

/** Name of the address resource to delete. */
@property(copy, nullable) NSString *address;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @returns GTLRComputeQuery_AddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource.
 *
 *  Method: compute.addresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesGetWithproject:region:address:]

/** Name of the address resource to return. */
@property(copy, nullable) NSString *address;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to return.
 *
 *  @returns GTLRComputeQuery_AddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.addresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_AddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  Method: compute.addresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAddressesListWithproject:region:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_AddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves an aggregated list of autoscalers.
 *
 *  Method: compute.autoscalers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AutoscalerAggregatedList.
 *
 *  Retrieves an aggregated list of autoscalers.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified autoscaler.
 *
 *  Method: compute.autoscalers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersDeleteWithproject:zoneProperty:autoscaler:]

/** Name of the autoscaler to delete. */
@property(copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to delete.
 *
 *  @returns GTLRComputeQuery_AutoscalersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Returns the specified autoscaler resource. Get a list of available
 *  autoscalers by making a list() request.
 *
 *  Method: compute.autoscalers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersGetWithproject:zoneProperty:autoscaler:]

/** Name of the autoscaler to return. */
@property(copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Autoscaler.
 *
 *  Returns the specified autoscaler resource. Get a list of available
 *  autoscalers by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to return.
 *
 *  @returns GTLRComputeQuery_AutoscalersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  Method: compute.autoscalers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AutoscalerList.
 *
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports patch semantics.
 *
 *  Method: compute.autoscalers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersPatchWithObject:project:zoneProperty:autoscaler:]

/** Name of the autoscaler to update. */
@property(copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports patch semantics.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to update.
 *
 *  @returns GTLRComputeQuery_AutoscalersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                     autoscaler:(NSString *)autoscaler;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForAutoscalersUpdateWithObject:project:zoneProperty:]

/** Name of the autoscaler to update. */
@property(copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_AutoscalersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified BackendService resource.
 *
 *  Method: compute.backendServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesDeleteWithproject:backendService:]

/** Name of the BackendService resource to delete. */
@property(copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to delete.
 *
 *  @returns GTLRComputeQuery_BackendServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Returns the specified BackendService resource. Get a list of available
 *  backend services by making a list() request.
 *
 *  Method: compute.backendServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesGetWithproject:backendService:]

/** Name of the BackendService resource to return. */
@property(copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendService.
 *
 *  Returns the specified BackendService resource. Get a list of available
 *  backend services by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to return.
 *
 *  @returns GTLRComputeQuery_BackendServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Gets the most recent health check results for this BackendService.
 *
 *  Method: compute.backendServices.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesGetHealthWithObject:project:backendService:]

/**
 *  Name of the BackendService resource to which the queried instance belongs.
 */
@property(copy, nullable) NSString *backendService;

@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceGroupHealth.
 *
 *  Gets the most recent health check results for this BackendService.
 *
 *  @param object The @c GTLRCompute_ResourceGroupReference to include in the
 *    query.
 *  @param project NSString
 *  @param backendService Name of the BackendService resource to which the
 *    queried instance belongs.
 *
 *  @returns GTLRComputeQuery_BackendServicesGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourceGroupReference *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when creating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  Method: compute.backendServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. There are several restrictions and guidelines to
 *  keep in mind when creating a backend service. Read Restrictions and
 *  Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_BackendServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  Method: compute.backendServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceList.
 *
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_BackendServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the entire content of the BackendService resource. There are several
 *  restrictions and guidelines to keep in mind when updating a backend service.
 *  Read Restrictions and Guidelines for more information. This method supports
 *  patch semantics.
 *
 *  Method: compute.backendServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesPatchWithObject:project:backendService:]

/** Name of the BackendService resource to update. */
@property(copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the entire content of the BackendService resource. There are several
 *  restrictions and guidelines to keep in mind when updating a backend service.
 *  Read Restrictions and Guidelines for more information. This method supports
 *  patch semantics.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @returns GTLRComputeQuery_BackendServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Updates the entire content of the BackendService resource. There are several
 *  restrictions and guidelines to keep in mind when updating a backend service.
 *  Read Restrictions and Guidelines for more information.
 *
 *  Method: compute.backendServices.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForBackendServicesUpdateWithObject:project:backendService:]

/** Name of the BackendService resource to update. */
@property(copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the entire content of the BackendService resource. There are several
 *  restrictions and guidelines to keep in mind when updating a backend service.
 *  Read Restrictions and Guidelines for more information.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @returns GTLRComputeQuery_BackendServicesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves an aggregated list of persistent disks.
 *
 *  Method: compute.disks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_DiskAggregatedList.
 *
 *  Retrieves an aggregated list of persistent disks.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_DisksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Creates a snapshot of a specified persistent disk.
 *
 *  Method: compute.disks.createSnapshot
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksCreateSnapshot : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksCreateSnapshotWithObject:project:zoneProperty:disk:]

/** Name of the persistent disk to snapshot. */
@property(copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a snapshot of a specified persistent disk.
 *
 *  @param object The @c GTLRCompute_Snapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to snapshot.
 *
 *  @returns GTLRComputeQuery_DisksCreateSnapshot
 */
+ (instancetype)queryWithObject:(GTLRCompute_Snapshot *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  Method: compute.disks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksDeleteWithproject:zoneProperty:disk:]

/** Name of the persistent disk to delete. */
@property(copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to delete.
 *
 *  @returns GTLRComputeQuery_DisksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Returns a specified persistent disk. Get a list of available persistent
 *  disks by making a list() request.
 *
 *  Method: compute.disks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksGetWithproject:zoneProperty:disk:]

/** Name of the persistent disk to return. */
@property(copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Disk.
 *
 *  Returns a specified persistent disk. Get a list of available persistent
 *  disks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to return.
 *
 *  @returns GTLRComputeQuery_DisksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk with a sourceImage, a sourceSnapshot, or
 *  create an empty 500 GB data disk by omitting all properties. You can also
 *  create a disk that is larger than the default size by specifying the sizeGb
 *  property.
 *
 *  Method: compute.disks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Optional. Source image to restore onto a disk. */
@property(copy, nullable) NSString *sourceImage;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk with a sourceImage, a sourceSnapshot, or
 *  create an empty 500 GB data disk by omitting all properties. You can also
 *  create a disk that is larger than the default size by specifying the sizeGb
 *  property.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_DisksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  Method: compute.disks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskList.
 *
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_DisksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Resizes the specified persistent disk.
 *
 *  Method: compute.disks.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDisksResizeWithObject:project:zoneProperty:disk:]

/** The name of the persistent disk. */
@property(copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the specified persistent disk.
 *
 *  @param object The @c GTLRCompute_DisksResizeRequest to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @returns GTLRComputeQuery_DisksResize
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksResizeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Retrieves an aggregated list of disk types.
 *
 *  Method: compute.diskTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_DiskTypeAggregatedList.
 *
 *  Retrieves an aggregated list of disk types.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_DiskTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified disk type. Get a list of available disk types by
 *  making a list() request.
 *
 *  Method: compute.diskTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesGetWithproject:zoneProperty:diskType:]

/** Name of the disk type to return. */
@property(copy, nullable) NSString *diskType;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskType.
 *
 *  Returns the specified disk type. Get a list of available disk types by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param diskType Name of the disk type to return.
 *
 *  @returns GTLRComputeQuery_DiskTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        diskType:(NSString *)diskType;

@end

/**
 *  Retrieves a list of disk types available to the specified project.
 *
 *  Method: compute.diskTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForDiskTypesListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskTypeList.
 *
 *  Retrieves a list of disk types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_DiskTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified firewall.
 *
 *  Method: compute.firewalls.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsDeleteWithproject:firewall:]

/** Name of the firewall rule to delete. */
@property(copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to delete.
 *
 *  @returns GTLRComputeQuery_FirewallsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Returns the specified firewall.
 *
 *  Method: compute.firewalls.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsGetWithproject:firewall:]

/** Name of the firewall rule to return. */
@property(copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Firewall.
 *
 *  Returns the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to return.
 *
 *  @returns GTLRComputeQuery_FirewallsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.firewalls.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_FirewallsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  Method: compute.firewalls.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_FirewallList.
 *
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_FirewallsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports patch semantics.
 *
 *  Method: compute.firewalls.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsPatchWithObject:project:firewall:]

/** Name of the firewall rule to update. */
@property(copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports patch semantics.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to update.
 *
 *  @returns GTLRComputeQuery_FirewallsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *
 *  Method: compute.firewalls.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForFirewallsUpdateWithObject:project:firewall:]

/** Name of the firewall rule to update. */
@property(copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to update.
 *
 *  @returns GTLRComputeQuery_FirewallsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Retrieves an aggregated list of forwarding rules.
 *
 *  Method: compute.forwardingRules.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleAggregatedList.
 *
 *  Retrieves an aggregated list of forwarding rules.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesDeleteWithproject:region:forwardingRule:]

/** Name of the ForwardingRule resource to delete. */
@property(copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesGetWithproject:region:forwardingRule:]

/** Name of the ForwardingRule resource to return. */
@property(copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.forwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesInsertWithObject:project:region:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  Method: compute.forwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesListWithproject:region:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  Method: compute.forwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesSetTarget : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForForwardingRulesSetTargetWithObject:project:region:forwardingRule:]

/** Name of the ForwardingRule resource in which target is to be set. */
@property(copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @returns GTLRComputeQuery_ForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.globalAddresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesDeleteWithproject:address:]

/** Name of the address resource to delete. */
@property(copy, nullable) NSString *address;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource. Get a list of available addresses by
 *  making a list() request.
 *
 *  Method: compute.globalAddresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesGetWithproject:address:]

/** Name of the address resource to return. */
@property(copy, nullable) NSString *address;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource. Get a list of available addresses by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to return.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.globalAddresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of global addresses.
 *
 *  Method: compute.globalAddresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalAddressesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of global addresses.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalAddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified ForwardingRule resource.
 *
 *  Method: compute.globalForwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesDeleteWithproject:forwardingRule:]

/** Name of the ForwardingRule resource to delete. */
@property(copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified ForwardingRule resource. Get a list of available
 *  forwarding rules by making a list() request.
 *
 *  Method: compute.globalForwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesGetWithproject:forwardingRule:]

/** Name of the ForwardingRule resource to return. */
@property(copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified ForwardingRule resource. Get a list of available
 *  forwarding rules by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.globalForwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project.
 *
 *  Method: compute.globalForwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  Method: compute.globalForwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesSetTarget : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalForwardingRulesSetTargetWithObject:project:forwardingRule:]

/** Name of the ForwardingRule resource in which target is to be set. */
@property(copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @returns GTLRComputeQuery_GlobalForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Retrieves an aggregated list of all operations.
 *
 *  Method: compute.globalOperations.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_OperationAggregatedList.
 *
 *  Retrieves an aggregated list of all operations.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Operations resource.
 *
 *  Method: compute.globalOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsDeleteWithproject:operation:]

/** Name of the Operations resource to delete. */
@property(copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified Operations resource. Get a list of operations by
 *  making a list() request.
 *
 *  Method: compute.globalOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsGetWithproject:operation:]

/** Name of the Operations resource to return. */
@property(copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified Operations resource. Get a list of operations by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  Method: compute.globalOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForGlobalOperationsListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_GlobalOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  Method: compute.httpHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksDeleteWithproject:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to delete. */
@property(copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to delete.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Returns the specified HttpHealthCheck resource. Get a list of available HTTP
 *  health checks by making a list() request.
 *
 *  Method: compute.httpHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksGetWithproject:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to return. */
@property(copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheck.
 *
 *  Returns the specified HttpHealthCheck resource. Get a list of available HTTP
 *  health checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to return.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheckList.
 *
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports patch semantics.
 *
 *  Method: compute.httpHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksPatchWithObject:project:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to update. */
@property(copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports patch semantics.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to update.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpHealthChecksUpdateWithObject:project:httpHealthCheck:]

/** Name of the HttpHealthCheck resource to update. */
@property(copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to update.
 *
 *  @returns GTLRComputeQuery_HttpHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  Method: compute.httpsHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksDeleteWithproject:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to delete. */
@property(copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to delete.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Returns the specified HttpsHealthCheck resource. Get a list of available
 *  HTTPS health checks by making a list() request.
 *
 *  Method: compute.httpsHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksGetWithproject:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to return. */
@property(copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheck.
 *
 *  Returns the specified HttpsHealthCheck resource. Get a list of available
 *  HTTPS health checks by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to return.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpsHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheckList.
 *
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports patch semantics.
 *
 *  Method: compute.httpsHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksPatchWithObject:project:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to update. */
@property(copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports patch semantics.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to update.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForHttpsHealthChecksUpdateWithObject:project:httpsHealthCheck:]

/** Name of the HttpsHealthCheck resource to update. */
@property(copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to update.
 *
 *  @returns GTLRComputeQuery_HttpsHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Deletes the specified image.
 *
 *  Method: compute.images.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesDeleteWithproject:image:]

/** Name of the image resource to delete. */
@property(copy, nullable) NSString *image;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified image.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to delete.
 *
 *  @returns GTLRComputeQuery_ImagesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Sets the deprecation status of an image.
 *  If an empty request body is given, clears the deprecation status instead.
 *
 *  Method: compute.images.deprecate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDeprecate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesDeprecateWithObject:project:image:]

/** Image name. */
@property(copy, nullable) NSString *image;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the deprecation status of an image.
 *  If an empty request body is given, clears the deprecation status instead.
 *
 *  @param object The @c GTLRCompute_DeprecationStatus to include in the query.
 *  @param project Project ID for this request.
 *  @param image Image name.
 *
 *  @returns GTLRComputeQuery_ImagesDeprecate
 */
+ (instancetype)queryWithObject:(GTLRCompute_DeprecationStatus *)object
                        project:(NSString *)project
                          image:(NSString *)image;

@end

/**
 *  Returns the specified image. Get a list of available images by making a
 *  list() request.
 *
 *  Method: compute.images.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesGetWithproject:image:]

/** Name of the image resource to return. */
@property(copy, nullable) NSString *image;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the specified image. Get a list of available images by making a
 *  list() request.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to return.
 *
 *  @returns GTLRComputeQuery_ImagesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Returns the latest image that is part of an image family and is not
 *  deprecated.
 *
 *  Method: compute.images.getFromFamily
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGetFromFamily : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesGetFromFamilyWithproject:family:]

/** Name of the image resource to return. */
@property(copy, nullable) NSString *family;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the latest image that is part of an image family and is not
 *  deprecated.
 *
 *  @param project Project ID for this request.
 *  @param family Name of the image resource to return.
 *
 *  @returns GTLRComputeQuery_ImagesGetFromFamily
 */
+ (instancetype)queryWithProject:(NSString *)project
                          family:(NSString *)family;

@end

/**
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.images.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ImagesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Image to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ImagesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Image *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of private images available to the specified project.
 *  Private images are images you create that belong to your project. This
 *  method does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 7. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *  See Accessing images for more information.
 *
 *  Method: compute.images.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForImagesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ImageList.
 *
 *  Retrieves the list of private images available to the specified project.
 *  Private images are images you create that belong to your project. This
 *  method does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 7. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *  See Accessing images for more information.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ImagesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Schedules a group action to remove the specified instances from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *
 *  Method: compute.instanceGroupManagers.abandonInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersAbandonInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersAbandonInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to remove the specified instances from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersAbandonInstancesRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersAbandonInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersAbandonInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Retrieves the list of managed instance groups and groups them by zone.
 *
 *  Method: compute.instanceGroupManagers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerAggregatedList.
 *
 *  Retrieves the list of managed instance groups and groups them by zone.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroupManagers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersDeleteWithproject:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group to delete. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group to
 *    delete.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Schedules a group action to delete the specified instances in the managed
 *  instance group. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. This operation is
 *  marked as DONE when the action is scheduled even if the instances are still
 *  being deleted. You must separately verify the status of the deleting action
 *  with the listmanagedinstances method.
 *
 *  Method: compute.instanceGroupManagers.deleteInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDeleteInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersDeleteInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to delete the specified instances in the managed
 *  instance group. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. This operation is
 *  marked as DONE when the action is scheduled even if the instances are still
 *  being deleted. You must separately verify the status of the deleting action
 *  with the listmanagedinstances method.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersDeleteInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersDeleteInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersDeleteInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns all of the details about the specified managed instance group. Get a
 *  list of available managed instance groups by making a list() request.
 *
 *  Method: compute.instanceGroupManagers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersGetWithproject:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManager.
 *
 *  Returns all of the details about the specified managed instance group. Get a
 *  list of available managed instance groups by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, it schedules an action to create
 *  instances in the group using the specified instance template. This operation
 *  is marked as DONE when the group is created even if the instances in the
 *  group have not yet been created. You must separately verify the status of
 *  the individual instances with the listmanagedinstances method.
 *
 *  Method: compute.instanceGroupManagers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where you want to create the managed instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, it schedules an action to create
 *  instances in the group using the specified instance template. This operation
 *  is marked as DONE when the group is created even if the instances in the
 *  group have not yet been created. You must separately verify the status of
 *  the individual instances with the listmanagedinstances method.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  Method: compute.instanceGroupManagers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerList.
 *
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action.
 *
 *  Method: compute.instanceGroupManagers.listManagedInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersListManagedInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersListManagedInstancesWithproject:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagersListManagedInstancesResponse.
 *
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersListManagedInstances
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Schedules a group action to recreate the specified instances in the managed
 *  instance group. The instances are deleted and recreated using the current
 *  instance template for the managed instance group. This operation is marked
 *  as DONE when the action is scheduled even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *
 *  Method: compute.instanceGroupManagers.recreateInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersRecreateInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersRecreateInstancesWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Schedules a group action to recreate the specified instances in the managed
 *  instance group. The instances are deleted and recreated using the current
 *  instance template for the managed instance group. This operation is marked
 *  as DONE when the action is scheduled even if the instances have not yet been
 *  recreated. You must separately verify the status of the recreating action
 *  with the listmanagedinstances method.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersRecreateInstancesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersRecreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersRecreateInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *
 *  Method: compute.instanceGroupManagers.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersResize : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersResizeWithproject:zoneProperty:instanceGroupManager:size:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The number of running instances that the managed instance group should
 *  maintain at any given time. The group automatically adds or removes
 *  instances to maintain the number of instances specified by this parameter.
 */
@property(assign) NSInteger size;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *  @param size The number of running instances that the managed instance group
 *    should maintain at any given time. The group automatically adds or removes
 *    instances to maintain the number of instances specified by this parameter.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersResize
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager
                            size:(NSInteger)size;

@end

/**
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you recreate them.
 *
 *  Method: compute.instanceGroupManagers.setInstanceTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersSetInstanceTemplateWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you recreate them.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  Method: compute.instanceGroupManagers.setTargetPools
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetTargetPools : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupManagersSetTargetPoolsWithObject:project:zoneProperty:instanceGroupManager:]

/** The name of the managed instance group. */
@property(copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupManagersSetTargetPools
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  Method: compute.instanceGroups.addInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsAddInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsAddInstancesWithObject:project:zoneProperty:instanceGroup:]

/** The name of the instance group where you are adding instances. */
@property(copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsAddInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where you are adding
 *    instances.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsAddInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsAddInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Retrieves the list of instance groups and sorts them by zone.
 *
 *  Method: compute.instanceGroups.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupAggregatedList.
 *
 *  Retrieves the list of instance groups and sorts them by zone.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsDeleteWithproject:zoneProperty:instanceGroup:]

/** The name of the instance group to delete. */
@property(copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group to delete.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Returns the specified instance group. Get a list of available instance
 *  groups by making a list() request.
 *
 *  Method: compute.instanceGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsGetWithproject:zoneProperty:instanceGroup:]

/** The name of the instance group. */
@property(copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroup.
 *
 *  Returns the specified instance group. Get a list of available instance
 *  groups by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  Method: compute.instanceGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where you want to create the instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  @param object The @c GTLRCompute_InstanceGroup to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    instance group.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of instance groups that are located in the specified
 *  project and zone.
 *
 *  Method: compute.instanceGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupList.
 *
 *  Retrieves the list of instance groups that are located in the specified
 *  project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists the instances in the specified instance group.
 *
 *  Method: compute.instanceGroups.listInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsListInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsListInstancesWithObject:project:zoneProperty:instanceGroup:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The name of the instance group from which you want to generate a list of
 *  included instances.
 */
@property(copy, nullable) NSString *instanceGroup;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupsListInstances.
 *
 *  Lists the instances in the specified instance group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsListInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group from which you want to
 *    generate a list of included instances.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsListInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsListInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances.
 *
 *  Method: compute.instanceGroups.removeInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsRemoveInstances : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsRemoveInstancesWithObject:project:zoneProperty:instanceGroup:]

/**
 *  The name of the instance group where the specified instances will be
 *  removed.
 */
@property(copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsRemoveInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the specified
 *    instances will be removed.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsRemoveInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsRemoveInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Sets the named ports for the specified instance group.
 *
 *  Method: compute.instanceGroups.setNamedPorts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsSetNamedPorts : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceGroupsSetNamedPortsWithObject:project:zoneProperty:instanceGroup:]

/** The name of the instance group where the named ports are updated. */
@property(copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the named ports for the specified instance group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsSetNamedPortsRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the named ports
 *    are updated.
 *
 *  @returns GTLRComputeQuery_InstanceGroupsSetNamedPorts
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsSetNamedPortsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Adds an access config to an instance's network interface.
 *
 *  Method: compute.instances.addAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAddAccessConfig : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAddAccessConfigWithObject:project:zoneProperty:instance:networkInterface:]

/** The instance name for this request. */
@property(copy, nullable) NSString *instance;

/** The name of the network interface to add to this instance. */
@property(copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an access config to an instance's network interface.
 *
 *  @param object The @c GTLRCompute_AccessConfig to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface to add to this
 *    instance.
 *
 *  @returns GTLRComputeQuery_InstancesAddAccessConfig
 */
+ (instancetype)queryWithObject:(GTLRCompute_AccessConfig *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Retrieves aggregated list of instances.
 *
 *  Method: compute.instances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceAggregatedList.
 *
 *  Retrieves aggregated list of instances.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Attaches a Disk resource to an instance.
 *
 *  Method: compute.instances.attachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAttachDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesAttachDiskWithObject:project:zoneProperty:instance:]

/** The instance name for this request. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Attaches a Disk resource to an instance.
 *
 *  @param object The @c GTLRCompute_AttachedDisk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *
 *  @returns GTLRComputeQuery_InstancesAttachDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_AttachedDisk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Deletes the specified Instance resource. For more information, see Stopping
 *  or Deleting an Instance.
 *
 *  Method: compute.instances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDeleteWithproject:zoneProperty:instance:]

/** Name of the instance resource to delete. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Instance resource. For more information, see Stopping
 *  or Deleting an Instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to delete.
 *
 *  @returns GTLRComputeQuery_InstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Deletes an access config from an instance's network interface.
 *
 *  Method: compute.instances.deleteAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDeleteAccessConfig : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDeleteAccessConfigWithproject:zoneProperty:instance:accessConfig:networkInterface:]

/** The name of the access config to delete. */
@property(copy, nullable) NSString *accessConfig;

/** The instance name for this request. */
@property(copy, nullable) NSString *instance;

/** The name of the network interface. */
@property(copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes an access config from an instance's network interface.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param accessConfig The name of the access config to delete.
 *  @param networkInterface The name of the network interface.
 *
 *  @returns GTLRComputeQuery_InstancesDeleteAccessConfig
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                    accessConfig:(NSString *)accessConfig
                networkInterface:(NSString *)networkInterface;

@end

/**
 *  Detaches a disk from an instance.
 *
 *  Method: compute.instances.detachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDetachDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesDetachDiskWithproject:zoneProperty:instance:deviceName:]

/** Disk device name to detach. */
@property(copy, nullable) NSString *deviceName;

/** Instance name. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Detaches a disk from an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name.
 *  @param deviceName Disk device name to detach.
 *
 *  @returns GTLRComputeQuery_InstancesDetachDisk
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Returns the specified Instance resource. Get a list of available instances
 *  by making a list() request.
 *
 *  Method: compute.instances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesGetWithproject:zoneProperty:instance:]

/** Name of the instance resource to return. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Instance.
 *
 *  Returns the specified Instance resource. Get a list of available instances
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to return.
 *
 *  @returns GTLRComputeQuery_InstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Returns the specified instance's serial port output.
 *
 *  Method: compute.instances.getSerialPortOutput
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetSerialPortOutput : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesGetSerialPortOutputWithproject:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(copy, nullable) NSString *instance;

/**
 *  Specifies which COM or serial port to retrieve data from.
 *
 *  @note If not set, the documented server-side default will be 1 (from the
 *        range 1..4).
 */
@property(assign) NSInteger port;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_SerialPortOutput.
 *
 *  Returns the specified instance's serial port output.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesGetSerialPortOutput
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.instances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Instance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_InstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Instance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  Method: compute.instances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceList.
 *
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_InstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Performs a hard reset on the instance.
 *
 *  Method: compute.instances.reset
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesReset : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesResetWithproject:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Performs a hard reset on the instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesReset
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  Method: compute.instances.setDiskAutoDelete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetDiskAutoDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetDiskAutoDeleteWithproject:zoneProperty:instance:autoDelete:deviceName:]

/** Whether to auto-delete the disk when the instance is deleted. */
@property(assign) BOOL autoDelete;

/** The device name of the disk to modify. */
@property(copy, nullable) NSString *deviceName;

/** The instance name. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name.
 *  @param autoDelete Whether to auto-delete the disk when the instance is
 *    deleted.
 *  @param deviceName The device name of the disk to modify.
 *
 *  @returns GTLRComputeQuery_InstancesSetDiskAutoDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      autoDelete:(BOOL)autoDelete
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  Method: compute.instances.setMachineType
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMachineType : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMachineTypeWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  @param object The @c GTLRCompute_InstancesSetMachineTypeRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetMachineType
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMachineTypeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  Method: compute.instances.setMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMetadata : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetMetadataWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets an instance's scheduling options.
 *
 *  Method: compute.instances.setScheduling
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetScheduling : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetSchedulingWithObject:project:zoneProperty:instance:]

/** Instance name. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets an instance's scheduling options.
 *
 *  @param object The @c GTLRCompute_Scheduling to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name.
 *
 *  @returns GTLRComputeQuery_InstancesSetScheduling
 */
+ (instancetype)queryWithObject:(GTLRCompute_Scheduling *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets tags for the specified instance to the data included in the request.
 *
 *  Method: compute.instances.setTags
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetTags : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesSetTagsWithObject:project:zoneProperty:instance:]

/** Name of the instance scoping this request. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets tags for the specified instance to the data included in the request.
 *
 *  @param object The @c GTLRCompute_Tags to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @returns GTLRComputeQuery_InstancesSetTags
 */
+ (instancetype)queryWithObject:(GTLRCompute_Tags *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Starts an instance that was stopped using the using the instances().stop
 *  method. For more information, see Restart an instance.
 *
 *  Method: compute.instances.start
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStart : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStartWithproject:zoneProperty:instance:]

/** Name of the instance resource to start. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts an instance that was stopped using the using the instances().stop
 *  method. For more information, see Restart an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @returns GTLRComputeQuery_InstancesStart
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur
 *  per-minute, virtual machine usage charges while they are stopped, but any
 *  resources that the virtual machine is using, such as persistent disks and
 *  static IP addresses, will continue to be charged until they are deleted. For
 *  more information, see Stopping an instance.
 *
 *  Method: compute.instances.stop
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStop : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstancesStopWithproject:zoneProperty:instance:]

/** Name of the instance resource to stop. */
@property(copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur
 *  per-minute, virtual machine usage charges while they are stopped, but any
 *  resources that the virtual machine is using, such as persistent disks and
 *  static IP addresses, will continue to be charged until they are deleted. For
 *  more information, see Stopping an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to stop.
 *
 *  @returns GTLRComputeQuery_InstancesStop
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Deletes the specified instance template. If you delete an instance template
 *  that is being referenced from another instance group, the instance group
 *  will not be able to create or recreate virtual machine instances. Deleting
 *  an instance template is permanent and cannot be undone.
 *
 *  Method: compute.instanceTemplates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesDeleteWithproject:instanceTemplate:]

/** The name of the instance template to delete. */
@property(copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance template. If you delete an instance template
 *  that is being referenced from another instance group, the instance group
 *  will not be able to create or recreate virtual machine instances. Deleting
 *  an instance template is permanent and cannot be undone.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template to delete.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Returns the specified instance template. Get a list of available instance
 *  templates by making a list() request.
 *
 *  Method: compute.instanceTemplates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesGetWithproject:instanceTemplate:]

/** The name of the instance template. */
@property(copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplate.
 *
 *  Returns the specified instance template. Get a list of available instance
 *  templates by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  Method: compute.instanceTemplates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  @param object The @c GTLRCompute_InstanceTemplate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceTemplate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of instance templates that are contained within the
 *  specified project and zone.
 *
 *  Method: compute.instanceTemplates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForInstanceTemplatesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplateList.
 *
 *  Retrieves a list of instance templates that are contained within the
 *  specified project and zone.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_InstanceTemplatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified License resource. Get a list of available licenses by
 *  making a list() request.
 *
 *  Method: compute.licenses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForLicensesGetWithproject:license:]

/** Name of the License resource to return. */
@property(copy, nullable) NSString *license;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_License.
 *
 *  Returns the specified License resource. Get a list of available licenses by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param license Name of the License resource to return.
 *
 *  @returns GTLRComputeQuery_LicensesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         license:(NSString *)license;

@end

/**
 *  Retrieves an aggregated list of machine types.
 *
 *  Method: compute.machineTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_MachineTypeAggregatedList.
 *
 *  Retrieves an aggregated list of machine types.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_MachineTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified machine type. Get a list of available machine types by
 *  making a list() request.
 *
 *  Method: compute.machineTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesGetWithproject:zoneProperty:machineType:]

/** Name of the machine type to return. */
@property(copy, nullable) NSString *machineType;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineType.
 *
 *  Returns the specified machine type. Get a list of available machine types by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param machineType Name of the machine type to return.
 *
 *  @returns GTLRComputeQuery_MachineTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     machineType:(NSString *)machineType;

@end

/**
 *  Retrieves a list of machine types available to the specified project.
 *
 *  Method: compute.machineTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForMachineTypesListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineTypeList.
 *
 *  Retrieves a list of machine types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @returns GTLRComputeQuery_MachineTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified network.
 *
 *  Method: compute.networks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksDeleteWithproject:network:]

/** Name of the network to delete. */
@property(copy, nullable) NSString *network;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to delete.
 *
 *  @returns GTLRComputeQuery_NetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Returns the specified network. Get a list of available networks by making a
 *  list() request.
 *
 *  Method: compute.networks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksGetWithproject:network:]

/** Name of the network to return. */
@property(copy, nullable) NSString *network;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Network.
 *
 *  Returns the specified network. Get a list of available networks by making a
 *  list() request.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to return.
 *
 *  @returns GTLRComputeQuery_NetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.networks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Network to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_NetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Network *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of networks available to the specified project.
 *
 *  Method: compute.networks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForNetworksListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NetworkList.
 *
 *  Retrieves the list of networks available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_NetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified Project resource.
 *
 *  Method: compute.projects.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ProjectsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsGetWithproject:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Project.
 *
 *  Returns the specified Project resource.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsGet
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Moves a persistent disk from one zone to another.
 *
 *  Method: compute.projects.moveDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsMoveDisk : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsMoveDiskWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves a persistent disk from one zone to another.
 *
 *  @param object The @c GTLRCompute_DiskMoveRequest to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsMoveDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_DiskMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Moves an instance and its attached persistent disks from one zone to
 *  another.
 *
 *  Method: compute.projects.moveInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsMoveInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsMoveInstanceWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves an instance and its attached persistent disks from one zone to
 *  another.
 *
 *  @param object The @c GTLRCompute_InstanceMoveRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsMoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  Method: compute.projects.setCommonInstanceMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsSetCommonInstanceMetadata : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsSetCommonInstanceMetadataWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsSetCommonInstanceMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project;

@end

/**
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  Method: compute.projects.setUsageExportBucket
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ProjectsSetUsageExportBucket : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForProjectsSetUsageExportBucketWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  @param object The @c GTLRCompute_UsageExportLocation to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ProjectsSetUsageExportBucket
 */
+ (instancetype)queryWithObject:(GTLRCompute_UsageExportLocation *)object
                        project:(NSString *)project;

@end

/**
 *  Deletes the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsDeleteWithproject:region:operation:]

/** Name of the Operations resource to delete. */
@property(copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @returns GTLRComputeQuery_RegionOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsGetWithproject:region:operation:]

/** Name of the Operations resource to return. */
@property(copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @returns GTLRComputeQuery_RegionOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  Method: compute.regionOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionOperationsListWithproject:region:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_RegionOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Returns the specified Region resource. Get a list of available regions by
 *  making a list() request.
 *
 *  Method: compute.regions.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionsGetWithproject:region:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region resource to return. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Region.
 *
 *  Returns the specified Region resource. Get a list of available regions by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region resource to return.
 *
 *  @returns GTLRComputeQuery_RegionsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves the list of region resources available to the specified project.
 *
 *  Method: compute.regions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRegionsListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RegionList.
 *
 *  Retrieves the list of region resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RegionsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Route resource.
 *
 *  Method: compute.routes.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesDeleteWithproject:route:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the Route resource to delete. */
@property(copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Route resource.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to delete.
 *
 *  @returns GTLRComputeQuery_RoutesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Returns the specified Route resource. Get a list of available routes by
 *  making a list() request.
 *
 *  Method: compute.routes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesGetWithproject:route:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the Route resource to return. */
@property(copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Route.
 *
 *  Returns the specified Route resource. Get a list of available routes by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to return.
 *
 *  @returns GTLRComputeQuery_RoutesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.routes.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Route to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RoutesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Route *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  Method: compute.routes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForRoutesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_RouteList.
 *
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_RoutesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot.
 *  For more information, see Deleting snaphots.
 *
 *  Method: compute.snapshots.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsDeleteWithproject:snapshot:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the Snapshot resource to delete. */
@property(copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot.
 *  For more information, see Deleting snaphots.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to delete.
 *
 *  @returns GTLRComputeQuery_SnapshotsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Returns the specified Snapshot resource. Get a list of available snapshots
 *  by making a list() request.
 *
 *  Method: compute.snapshots.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsGetWithproject:snapshot:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the Snapshot resource to return. */
@property(copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Snapshot.
 *
 *  Returns the specified Snapshot resource. Get a list of available snapshots
 *  by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to return.
 *
 *  @returns GTLRComputeQuery_SnapshotsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  Method: compute.snapshots.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSnapshotsListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SnapshotList.
 *
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SnapshotsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified SslCertificate resource.
 *
 *  Method: compute.sslCertificates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesDeleteWithproject:sslCertificate:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the SslCertificate resource to delete. */
@property(copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SslCertificate resource.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to delete.
 *
 *  @returns GTLRComputeQuery_SslCertificatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Returns the specified SslCertificate resource. Get a list of available SSL
 *  certificates by making a list() request.
 *
 *  Method: compute.sslCertificates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesGetWithproject:sslCertificate:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the SslCertificate resource to return. */
@property(copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_SslCertificate.
 *
 *  Returns the specified SslCertificate resource. Get a list of available SSL
 *  certificates by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to return.
 *
 *  @returns GTLRComputeQuery_SslCertificatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.sslCertificates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_SslCertificate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SslCertificatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslCertificate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  Method: compute.sslCertificates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSslCertificatesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SslCertificateList.
 *
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SslCertificatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Retrieves an aggregated list of subnetworks.
 *
 *  Method: compute.subnetworks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SubnetworkAggregatedList.
 *
 *  Retrieves an aggregated list of subnetworks.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_SubnetworksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified subnetwork.
 *
 *  Method: compute.subnetworks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksDeleteWithproject:region:subnetwork:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the Subnetwork resource to delete. */
@property(copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified subnetwork.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to delete.
 *
 *  @returns GTLRComputeQuery_SubnetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Returns the specified subnetwork. Get a list of available subnetworks list()
 *  request.
 *
 *  Method: compute.subnetworks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksGetWithproject:region:subnetwork:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the Subnetwork resource to return. */
@property(copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Subnetwork.
 *
 *  Returns the specified subnetwork. Get a list of available subnetworks list()
 *  request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to return.
 *
 *  @returns GTLRComputeQuery_SubnetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.subnetworks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksInsertWithObject:project:region:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Subnetwork to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_SubnetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Subnetwork *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  Method: compute.subnetworks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForSubnetworksListWithproject:region:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_SubnetworkList.
 *
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_SubnetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  Method: compute.targetHttpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesDeleteWithproject:targetHttpProxy:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetHttpProxy resource to delete. */
@property(copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Returns the specified TargetHttpProxy resource. Get a list of available
 *  target HTTP proxies by making a list() request.
 *
 *  Method: compute.targetHttpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesGetWithproject:targetHttpProxy:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetHttpProxy resource to return. */
@property(copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxy.
 *
 *  Returns the specified TargetHttpProxy resource. Get a list of available
 *  target HTTP proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to return.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxyList.
 *
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the URL map for TargetHttpProxy.
 *
 *  Method: compute.targetHttpProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesSetUrlMap : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpProxiesSetUrlMapWithObject:project:targetHttpProxy:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetHttpProxy to set a URL map for. */
@property(copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy to set a URL map for.
 *
 *  @returns GTLRComputeQuery_TargetHttpProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
                targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  Method: compute.targetHttpsProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesDeleteWithproject:targetHttpsProxy:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetHttpsProxy resource to delete. */
@property(copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Returns the specified TargetHttpsProxy resource. Get a list of available
 *  target HTTPS proxies by making a list() request.
 *
 *  Method: compute.targetHttpsProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesGetWithproject:targetHttpsProxy:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetHttpsProxy resource to return. */
@property(copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxy.
 *
 *  Returns the specified TargetHttpsProxy resource. Get a list of available
 *  target HTTPS proxies by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to return.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpsProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpsProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxyList.
 *
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetSslCertificatesWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the TargetHttpsProxy resource to set an SslCertificates resource
 *  for.
 */
@property(copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to set an
 *    SslCertificates resource for.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetUrlMap : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetHttpsProxiesSetUrlMapWithObject:project:targetHttpsProxy:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetHttpsProxy resource whose URL map is to be set. */
@property(copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource whose URL map
 *    is to be set.
 *
 *  @returns GTLRComputeQuery_TargetHttpsProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Retrieves an aggregated list of target instances.
 *
 *  Method: compute.targetInstances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceAggregatedList.
 *
 *  Retrieves an aggregated list of target instances.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetInstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified TargetInstance resource.
 *
 *  Method: compute.targetInstances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesDeleteWithproject:zoneProperty:targetInstance:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetInstance resource to delete. */
@property(copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetInstance resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetInstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Returns the specified TargetInstance resource. Get a list of available
 *  target instances by making a list() request.
 *
 *  Method: compute.targetInstances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesGetWithproject:zoneProperty:targetInstance:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the TargetInstance resource to return. */
@property(copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstance.
 *
 *  Returns the specified TargetInstance resource. Get a list of available
 *  target instances by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to return.
 *
 *  @returns GTLRComputeQuery_TargetInstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  Method: compute.targetInstances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesInsertWithObject:project:zoneProperty:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetInstance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetInstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetInstance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  Method: compute.targetInstances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetInstancesListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceList.
 *
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetInstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Adds health check URLs to a target pool.
 *
 *  Method: compute.targetPools.addHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddHealthCheck : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAddHealthCheckWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the target pool to add a health check to. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds health check URLs to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddHealthCheckRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the target pool to add a health check to.
 *
 *  @returns GTLRComputeQuery_TargetPoolsAddHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Adds an instance to a target pool.
 *
 *  Method: compute.targetPools.addInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAddInstanceWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the TargetPool resource to add instances to. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an instance to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddInstanceRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to add instances to.
 *
 *  @returns GTLRComputeQuery_TargetPoolsAddInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Retrieves an aggregated list of target pools.
 *
 *  Method: compute.targetPools.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetPoolAggregatedList.
 *
 *  Retrieves an aggregated list of target pools.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetPoolsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target pool.
 *
 *  Method: compute.targetPools.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsDeleteWithproject:region:targetPool:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the TargetPool resource to delete. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target pool.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to delete.
 *
 *  @returns GTLRComputeQuery_TargetPoolsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Returns the specified target pool. Get a list of available target pools by
 *  making a list() request.
 *
 *  Method: compute.targetPools.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsGetWithproject:region:targetPool:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the TargetPool resource to return. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPool.
 *
 *  Returns the specified target pool. Get a list of available target pools by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to return.
 *
 *  @returns GTLRComputeQuery_TargetPoolsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  Method: compute.targetPools.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGetHealth : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsGetHealthWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the TargetPool resource to which the queried instance belongs. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPoolInstanceHealth.
 *
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  @param object The @c GTLRCompute_InstanceReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to which the queried
 *    instance belongs.
 *
 *  @returns GTLRComputeQuery_TargetPoolsGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.targetPools.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetPool to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetPoolsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPool *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  Method: compute.targetPools.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsListWithproject:region:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_TargetPoolList.
 *
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @returns GTLRComputeQuery_TargetPoolsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Removes health check URL from a target pool.
 *
 *  Method: compute.targetPools.removeHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveHealthCheck : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsRemoveHealthCheckWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/** Name of the target pool to remove health checks from. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes health check URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveHealthCheckRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetPool Name of the target pool to remove health checks from.
 *
 *  @returns GTLRComputeQuery_TargetPoolsRemoveHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Removes instance URL from a target pool.
 *
 *  Method: compute.targetPools.removeInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveInstance : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsRemoveInstanceWithObject:project:region:targetPool:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the TargetPool resource to remove instances from. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes instance URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveInstanceRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to remove instances from.
 *
 *  @returns GTLRComputeQuery_TargetPoolsRemoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Changes a backup target pool's configurations.
 *
 *  Method: compute.targetPools.setBackup
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsSetBackup : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetPoolsSetBackupWithObject:project:region:targetPool:]

/** New failoverRatio value for the target pool. */
@property(assign) float failoverRatio;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(copy, nullable) NSString *region;

/** Name of the TargetPool resource to set a backup pool for. */
@property(copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes a backup target pool's configurations.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to set a backup pool for.
 *
 *  @returns GTLRComputeQuery_TargetPoolsSetBackup
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Retrieves an aggregated list of target VPN gateways.
 *
 *  Method: compute.targetVpnGateways.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayAggregatedList.
 *
 *  Retrieves an aggregated list of target VPN gateways.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target VPN gateway.
 *
 *  Method: compute.targetVpnGateways.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysDeleteWithproject:region:targetVpnGateway:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/** Name of the target VPN gateway to delete. */
@property(copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to delete.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Returns the specified target VPN gateway. Get a list of available target VPN
 *  gateways by making a list() request.
 *
 *  Method: compute.targetVpnGateways.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysGetWithproject:region:targetVpnGateway:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/** Name of the target VPN gateway to return. */
@property(copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGateway.
 *
 *  Returns the specified target VPN gateway. Get a list of available target VPN
 *  gateways by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to return.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.targetVpnGateways.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysInsertWithObject:project:region:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetVpnGateway to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetVpnGateway *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  Method: compute.targetVpnGateways.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForTargetVpnGatewaysListWithproject:region:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayList.
 *
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_TargetVpnGatewaysList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified UrlMap resource.
 *
 *  Method: compute.urlMaps.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsDeleteWithproject:urlMap:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the UrlMap resource to delete. */
@property(copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified UrlMap resource.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to delete.
 *
 *  @returns GTLRComputeQuery_UrlMapsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Returns the specified UrlMap resource. Get a list of available URL maps by
 *  making a list() request.
 *
 *  Method: compute.urlMaps.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsGetWithproject:urlMap:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the UrlMap resource to return. */
@property(copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMap.
 *
 *  Returns the specified UrlMap resource. Get a list of available URL maps by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to return.
 *
 *  @returns GTLRComputeQuery_UrlMapsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.urlMaps.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsInsertWithObject:project:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_UrlMapsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  Method: compute.urlMaps.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_UrlMapList.
 *
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_UrlMapsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the entire content of the UrlMap resource. This method supports
 *  patch semantics.
 *
 *  Method: compute.urlMaps.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsPatch : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsPatchWithObject:project:urlMap:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the UrlMap resource to update. */
@property(copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the entire content of the UrlMap resource. This method supports
 *  patch semantics.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to update.
 *
 *  @returns GTLRComputeQuery_UrlMapsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Updates the entire content of the UrlMap resource.
 *
 *  Method: compute.urlMaps.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsUpdate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsUpdateWithObject:project:urlMap:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the UrlMap resource to update. */
@property(copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the entire content of the UrlMap resource.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to update.
 *
 *  @returns GTLRComputeQuery_UrlMapsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  Method: compute.urlMaps.validate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsValidate : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForUrlMapsValidateWithObject:project:urlMap:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the UrlMap resource to be validated as. */
@property(copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMapsValidateResponse.
 *
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  @param object The @c GTLRCompute_UrlMapsValidateRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to be validated as.
 *
 *  @returns GTLRComputeQuery_UrlMapsValidate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapsValidateRequest *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves an aggregated list of VPN tunnels.
 *
 *  Method: compute.vpnTunnels.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsAggregatedList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsAggregatedListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelAggregatedList.
 *
 *  Retrieves an aggregated list of VPN tunnels.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified VpnTunnel resource.
 *
 *  Method: compute.vpnTunnels.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsDeleteWithproject:region:vpnTunnel:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/** Name of the VpnTunnel resource to delete. */
@property(copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified VpnTunnel resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to delete.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Returns the specified VpnTunnel resource. Get a list of available VPN
 *  tunnels by making a list() request.
 *
 *  Method: compute.vpnTunnels.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsGetWithproject:region:vpnTunnel:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/** Name of the VpnTunnel resource to return. */
@property(copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_VpnTunnel.
 *
 *  Returns the specified VpnTunnel resource. Get a list of available VPN
 *  tunnels by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to return.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.vpnTunnels.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsInsert : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsInsertWithObject:project:region:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_VpnTunnel to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_VpnTunnel *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  Method: compute.vpnTunnels.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForVpnTunnelsListWithproject:region:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelList.
 *
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @returns GTLRComputeQuery_VpnTunnelsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ZoneOperationsDelete : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsDeleteWithproject:zoneProperty:operation:]

/** Name of the Operations resource to delete. */
@property(copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to delete.
 *
 *  @returns GTLRComputeQuery_ZoneOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsGetWithproject:zoneProperty:operation:]

/** Name of the Operations resource to return. */
@property(copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to return.
 *
 *  @returns GTLRComputeQuery_ZoneOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  Method: compute.zoneOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZoneOperationsListWithproject:zoneProperty:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone for request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for request.
 *
 *  @returns GTLRComputeQuery_ZoneOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Returns the specified Zone resource. Get a list of available zones by making
 *  a list() request.
 *
 *  Method: compute.zones.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesGet : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZonesGetWithproject:zoneProperty:]

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Name of the zone resource to return.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Zone.
 *
 *  Returns the specified Zone resource. Get a list of available zones by making
 *  a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone resource to return.
 *
 *  @returns GTLRComputeQuery_ZonesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  Method: compute.zones.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesList : GTLRComputeQuery
// Previous library name was
//   +[GTLQueryCompute queryForZonesListWithproject:]

/**
 *  Sets a filter expression for filtering listed resources, in the form
 *  filter={expression}. Your {expression} must be in the format: field_name
 *  comparison_string literal_string.
 *  The field_name is the name of the field you want to compare. Only atomic
 *  field types are supported (string, number, boolean). The comparison_string
 *  must be either eq (equals) or ne (not equals). The literal_string is the
 *  string value to filter to. The literal value must be valid for the type of
 *  field you are filtering by (string, number, boolean). For string fields, the
 *  literal value is interpreted as a regular expression using RE2 syntax. The
 *  literal value must match the entire field.
 *  For example, to filter for instances that do not have a name of
 *  example-instance, you would use filter=name ne example-instance.
 *  Compute Engine Beta API Only: When filtering in the Beta API, you can also
 *  filter on nested fields. For example, you could filter on instances that
 *  have set the scheduling.automaticRestart field to true. Use filtering on
 *  nested fields to take advantage of labels to organize and search for results
 *  based on label values.
 *  The Beta API also supports filtering on multiple expressions by providing
 *  each separate expression within parentheses. For example,
 *  (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple
 *  expressions are treated as AND expressions, meaning that resources must
 *  match all expressions to pass the filters.
 */
@property(copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than maxResults, Compute Engine
 *  returns a nextPageToken that can be used to get the next page of results in
 *  subsequent list requests.
 *
 *  @note If not set, the documented server-side default will be 500 (from the
 *        range 0..500).
 */
@property(assign) NSUInteger maxResults;

/**
 *  Specifies a page token to use. Set pageToken to the nextPageToken returned
 *  by a previous list request to get the next page of results.
 */
@property(copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ZoneList.
 *
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @returns GTLRComputeQuery_ZonesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

NS_ASSUME_NONNULL_END
